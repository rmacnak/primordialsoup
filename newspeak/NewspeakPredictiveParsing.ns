(* A predictive LL(3) parser for Newspeak.

Faster than the CombinatorialParsing-based parser, and can be modified without requiring a platform reset.

Brazil 1021 -> 50ms.
NewspeakCompilation  250 -> 16ms.

Todo:
 - Accept class declarations without bodies.
 - Attach better source positions for synthetic parts like the default superclass clause.
 - Separate the AST building from the parsing, something like the parser calling various #acceptFoo methods that subclasses should implement. Then add the colorizing and source mirror subclasses. *)
class NewspeakPredictiveParsing usingPlatform: platform asts: asts = (
	|
	private List = platform collections List.

	private BlockAST = asts BlockAST.
	private CascadedSendAST = asts CascadedSendAST.
	private CharacterAST = asts CharacterAST.
	private ClassBodyAST = asts ClassBodyAST.
	private ClassDeclarationAST = asts ClassDeclarationAST.
	private ClassHeaderAST = asts ClassHeaderAST.
	private ClassPrefixAST = asts ClassPrefixAST.
	private CodeBodyAST = asts CodeBodyAST.
	private ImmutableSlotDefAST = asts ImmutableSlotDefAST.
	private InitializerAST = asts InitializerAST.
	private MessageAST = asts MessageAST.
	private MessagePatternAST = asts MessagePatternAST.
	private MethodAST = asts MethodAST.
	private MixinApplicationClassAST = asts MixinApplicationClassAST.
	private MutableSlotDefAST = asts MutableSlotDefAST.
	private NumberAST = asts NumberAST.
	private ReturnStatAST = asts ReturnStatAST.
	private SetterSendAST = asts SetterSendAST.
	private SideAST = asts SideAST.
	private StringAST = asts StringAST.
	private SymbolAST = asts SymbolAST.
	private TupleAST = asts TupleAST.
	private UnresolvedSendAST = asts UnresolvedSendAST.
	private VarDeclAST = asts VarDeclAST.
	private VariableAST = asts VariableAST.
	|
) (
class ParseError message: m position: p = Exception (
	|
	public message <String> = m.
	public position <Integer> = p.
	|
) (
public isKindOfParseError ^<Boolean> = (
	^true
)
public printString ^<String> = (
	^'ParseError: ' , message , ' at position ' , position asString
)
) : (
)
(* A recursive descent parser for Newspeak that looks up to 3 token ahead. *)
public class Parser for: string = Scanner for: string (
	|
	protected implicitReceiver = VariableAST new name: #'@here'.
	|
) (
defaultClassSide ^<SideAST> = (
	^SideAST new
		transientSlots: {};
		nestedClasses: {};
		methods: {}
)
defaultConstructorPattern ^<MessagePatternAST> = (
	^MessagePatternAST new selector: #new parameters: {}
)
defaultSuperclassClause ^<SendAST> = (
	^UnresolvedSendAST new
		receiver:
			(UnresolvedSendAST new
				receiver: implicitReceiver;
				message: (MessageAST new send: #Object with: {}));
		message:
			(MessageAST new send: #new with: {})
)
expected: expectedKind = (
	^(ParseError message: 'expected ' , expectedKind position: tokenStart) signal
)
public parseAccessModifierOpt ^<Symbol> = (
	tokenKind = #identifier ifTrue:
		[tokenValue = #public ifTrue: [advanceToken. ^#public].
		 tokenValue = #protected ifTrue: [advanceToken. ^#protected].
		 tokenValue = #private ifTrue: [advanceToken. ^#private]].
	^#protected
)
public parseBinaryExpression ^<ExpressionAST> = (
	(* binaryExpression = unaryExpression, binaryMsg star. *)
	| result message |

	result:: parseUnaryExpression.

	[peekHasBinaryMessage] whileTrue:
		[message:: parseBinaryMessage.
		 result:: UnresolvedSendAST new
			to: result send: message;
			start: result start; end: message end].

	^result
)
public parseBinaryMessage ^<MessageAST> = (
	(* binaryMsg = eventualSendOperator opt, binarySelector, unaryExpression. *)
	| messageStart isEventual selector argument |

	messageStart:: tokenStart.
	isEventual:: tokenKind = #'<-:'.
	isEventual ifTrue: [advanceToken].

	tokenKind = #binary ifFalse: [expected: 'binary selector'].
	selector:: tokenValue.
	advanceToken.
	argument:: parseUnaryExpression.

	^MessageAST new
		send: selector asSymbol with: {argument};
		isEventual: isEventual;
		start: messageStart; end: argument end
)
public parseBinaryMessagePattern ^<MessagePatternAST> = (
	(* 	binaryMsgPattern = binarySelector, slotDecl. *)
	| patternStart selector parameter pattern returnType |

	tokenKind = #binary ifFalse: [expected: 'binary selector'].
	patternStart:: tokenStart.
	selector:: tokenValue asSymbol.
	advanceToken.

	parameter:: parseParameterDeclaration.

	tokenKind = #'^' ifTrue: [returnType:: parseReturnType].

	^MessagePatternAST new
		selector: selector parameters: {parameter};
		returnType: returnType;
		start: patternStart; end: parameter end (* bogus *)
)
public parseCascadedMessage ^<MessageAST> = (
	tokenKind = #';' ifFalse: [expected: 'semicolon'].
	advanceToken.
	peekHasUnaryMessage ifTrue: [^parseUnaryMessage].
	peekHasBinaryMessage ifTrue: [^parseBinaryMessage].
	peekHasKeywordMessage ifTrue: [^parseKeywordMessage].
	expected: 'message'.
)
public parseCascadedMessageExpression ^<ExpressionAST> = (
	| result message |
	result:: parseKeywordExpression.
	result isKindOfSendNode ifFalse: [^result].
	result receiver = implicitReceiver ifTrue: [^result].

	[tokenKind = #';'] whileTrue:
		[message:: parseCascadedMessage.
		 result:: CascadedSendAST new
			to: result cascade: message;
			start: message start; end: message end].

	^result
)
public parseClassDeclaration ^<ClassDeclarationAST> = (
	(* classDeclaration = classHeader, sideDecl, classSideDecl opt *)

	| header instanceSide classSide |
	header:: parseClassHeader.
	instanceSide:: parseInstanceSide.
	tokenKind = #':'
		ifTrue: [classSide:: parseClassSide]
		ifFalse: [classSide:: defaultClassSide].

	^ClassDeclarationAST new
		header: header;
		instanceSide: instanceSide;
		classSide: classSide
)
public parseClassDeclarationEnd ^<ClassDeclarationAST> = (
	| result = parseClassDeclaration. |
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseClassHeader ^<ClassHeaderAST> = (
	(* classHeader =
		(accessModifier opt, (tokenFromSymbol: #class), identifier, messagePattern, equalSign,
		superclassClause opt, lparen, classComment opt,
		slotDecls opt, initExprs,  rparen) |
		(accessModifier opt, (tokenFromSymbol: #class), identifier, empty, equalSign,
		superclassClause opt, lparen, classComment opt,
		slotDecls opt,  initExprs, rparen). *)

	| declStart am name constructor superclassCall tempsBody inits declEnd |
	declStart:: extendedStart.
	(* transition: accept optional language id and category *)
	tokenKind = #identifier ifTrue:
		[(tokenValue startsWith: 'New') ifTrue:
			[advanceToken.
			 tokenKind = #string ifFalse: [expected: 'string'].
			 advanceToken]].
	am:: parseAccessModifierOpt.

	(tokenKind = #identifier and: [tokenValue = 'class']) ifFalse: [expected: 'class'].
	advanceToken.

	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	name:: tokenValue.
	advanceToken.

	(* Cheat: skipping binary message pattern. *)
	(tokenKind = #identifier or: [tokenKind = #keyword])
		ifTrue: [constructor:: parseMessagePattern]
		ifFalse: [constructor:: defaultConstructorPattern].

	(tokenKind = #binary and: [tokenValue = '=']) ifFalse: [expected: '='].
	advanceToken.

	tokenKind = #identifier
		ifTrue: [superclassCall:: parseSuperclassClause. superclassCall end]
		ifFalse: [superclassCall:: defaultSuperclassClause].

	tokenKind = #'(' ifFalse: [expected: '('].
	advanceToken.

	tempsBody:: parseTemporariesOpt.

	inits:: parseInitExpressions.

	tokenKind = #')' ifFalse: [expected: ')'].
	declEnd:: tokenEnd.
	advanceToken.

	^ClassHeaderAST new
		name: name asSymbol;
		constructor: constructor;
		superclassName: superclassCall receiver message selector;
		superclassCall: superclassCall receiver;
		superConstructorCall: superclassCall message;
		slots: tempsBody temporaries;
		isSeq: tempsBody isSeq;
		initExprs: inits;
		inheritanceChain: {superclassCall};
		accessModifier: am;
		start: declStart; end: declEnd
)
public parseClassHeaderForName = (
	(* classHeader =
		(accessModifier opt, (tokenFromSymbol: #class), identifier, messagePattern, equalSign,
		superclassClause opt, lparen, classComment opt,
		slotDecls opt, initExprs,  rparen) |
		(accessModifier opt, (tokenFromSymbol: #class), identifier, empty, equalSign,
		superclassClause opt, lparen, classComment opt,
		slotDecls opt,  initExprs, rparen). *)

	| declStart am name constructor superclassCall comment tempsBody inits declEnd x y |
	declStart:: tokenStart.
	am:: parseAccessModifierOpt.

	(tokenKind = #identifier and: [tokenValue = 'class']) ifFalse: [expected: 'class'].
	advanceToken.

	tokenKind = #identifier ifFalse: [expected: 'identifier'].
)
public parseClassSide ^<SideAST> = (
	(* classSideDecl = colon, lparen, category star, rparen. *)

	| methods = List new. |

	(tokenKind = #':') ifFalse: [expected: ':'].
	advanceToken.

	(tokenKind = #'(') ifFalse: [expected: '('].
	advanceToken.

	[tokenKind = #')'] whileFalse:
		[methods add: parseMethodDeclaration].

	advanceToken. (* Consume ) *)

	^SideAST new
		transientSlots: {};
		nestedClasses: {};
		methods: methods
)
public parseClosure ^<BlockAST> = (
	(* block = lbracket, blockParameters opt, codeBody, rbracket. *)
	| closureStart closureEnd parameters = List new. body |

	tokenKind = #'[' ifFalse: [expected: '['].
	closureStart:: tokenStart.
	advanceToken.

	tokenKind = #':' ifTrue:
		[[tokenKind = #':' ifFalse: [expected: ':'].
		  advanceToken.
		  parameters add: parseParameterDeclaration.
		  tokenKind = #binary and: [tokenValue = '|']] whileFalse.
		  advanceToken].

	body:: parseCodeBody.
	body parameters: parameters.

	tokenKind = #']' ifFalse: [expected: ']'].
	closureEnd:: tokenEnd.
	advanceToken.

	^BlockAST new
		body: body;
		start: closureStart;
		end: closureEnd
)
public parseClosureType = (
	(* blockType = lbracket, (nonEmptyBlockArgList | blockReturnType opt), rbracket *)
	(* :note: Closure types accept parameters without a pipe, but closures require the pipe when there are parameters. *)
	tokenKind = #'[' ifFalse: [expected: '['].
	advanceToken.

	tokenKind = #':' ifTrue:
		[[tokenKind = #':' ifFalse: [expected: ':'].
		  advanceToken.
		  parseTypeTerm.
		  tokenKind = #']' ifTrue:
			[advanceToken.
			 ^nil].
		  tokenKind = #binary and: [tokenValue = '|']] whileFalse.
		  advanceToken].

	tokenKind = #']' ifFalse: [parseTypeTerm].

	tokenKind = #']' ifFalse: [expected: ']'].
	advanceToken.
	^nil
)
public parseCodeBody ^<CodeBodyAST> = (
	(* codeBody = (literalMessageComment | comment | whitespace) star, temporaries opt, statements. *)
	| body statements |
	body:: parseTemporariesOpt.
	body statements: parseStatements.
	^body
)
public parseDoItExpressionEnd ^<CodeBodyAST> = (
	| result = parseCodeBody. |
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseExpression ^<ExpressionAST> = (
	(* expression = setterKeyword star, sendExpression. *)
	| setterMessages = List new. result |
	[tokenKind = #setter] whileTrue:
		[setterMessages add:
			(MessageAST new
				send: tokenValue asSymbol with: nil;
				start: tokenStart; end: tokenEnd).
		 advanceToken].

	result:: parseSendExpression.
	setterMessages size to: 1 by: -1 do:
		[:index | | setterMessage = setterMessages at: index. |
		setterMessage arguments: {result}.
		setterMessage end: result end.
		result:: SetterSendAST
			to: implicitReceiver
			send: setterMessage
			start: setterMessage start
			end: setterMessage end].
	^result
)
public parseInitExpressions ^<List[ExpressionAST]> = (
	(* initExprs = expression starSeparatedOrTerminatedBy: dot. *)
	| statements = List new. |

	[(* ~FIRST(EXPRESSION) *)
	 tokenKind = #'^' ifTrue: [^statements].
	 tokenKind = #']' ifTrue: [^statements].
	 tokenKind = #')' ifTrue: [^statements].
	 tokenKind = #'}' ifTrue: [^statements].
	 tokenKind = #'.' ifTrue: [^statements].
	 tokenKind = #':' ifTrue: [^statements].
	 tokenKind = #';' ifTrue: [^statements].
	 tokenKind = #binary ifTrue: [^statements].
	 tokenKind = #end ifTrue: [^statements].

	 statements add: parseExpression.
	 tokenKind = #'.' ifTrue: [advanceToken]] repeat.
)
public parseInstanceSide ^<SideAST> = (
	(* sideDecl = lparen, classDecl star, category star, rparen. *)

	|
	nestedClasses = List new.
	transientSlots = List new.
	methods = List new.
	|

	(tokenKind = #'(') ifFalse: [expected: '('].
	advanceToken.

	[peekHasClassDeclaration] whileTrue:
		[nestedClasses add: parseClassDeclaration].

	[peekHasTransientSlotDeclaration] whileTrue:
		[transientSlots add: parseTransientSlotDeclaration].

	[tokenKind = #')'] whileFalse:
		[methods add: parseMethodDeclaration].

	advanceToken. (* Consume ) *)

	^SideAST new
		transientSlots: transientSlots;
		nestedClasses: nestedClasses;
		methods: methods
)
public parseKeywordExpression ^<ExpressionAST> = (
	(* keywordExpression = binaryExpression, keywordMsg opt. *)
	| result message |

	result:: parseBinaryExpression.

	peekHasKeywordMessage ifFalse: [^result].

	message:: parseKeywordMessage.
	^UnresolvedSendAST new
		to: result send: message;
		start: result start; end: message end
)
public parseKeywordHereSend ^<ExpressionAST> = (
	(* keywordHereSend = keywordMsg. *)
	| message |
	message:: parseKeywordMessage.
	^UnresolvedSendAST new
		to: implicitReceiver send: message;
		start: message start; end: message end
)
public parseKeywordMessage ^<MessageAST> = (
	(* keywordMsg = eventualSendOperator opt, (keyword, binaryExpression) plus. *)
	| messageStart isEventual selector arguments = List new. |

	messageStart:: tokenStart.
	isEventual:: tokenKind = #'<-:'.
	isEventual ifTrue: [advanceToken].

	tokenKind = #keyword ifFalse: [expected: 'keyword'].
	selector:: tokenValue.
	advanceToken.
	arguments add: parseBinaryExpression.

	[tokenKind = #keyword] whileTrue:
		[selector:: selector, tokenValue.
		 advanceToken.
		 arguments add: parseBinaryExpression].

	^MessageAST new
		send: selector asSymbol with: arguments asArray;
		isEventual: isEventual;
		start: messageStart; end: arguments last end
)
public parseKeywordMessagePattern ^<MessagePatternAST> = (
	(* keywordMsgPattern = (keyword, slotDecl) plus. *)
	| patternStart selector parameters = List new. returnType |

	tokenKind = #keyword ifFalse: [expected: 'keyword'].
	patternStart:: tokenStart.
	selector:: tokenValue.
	advanceToken.
	parameters add: parseParameterDeclaration.

	[tokenKind = #keyword] whileTrue:
		[selector:: selector, tokenValue.
		 advanceToken.
		 parameters add: parseParameterDeclaration].

	tokenKind = #'^' ifTrue: [returnType:: parseReturnType].

	^MessagePatternAST new
		selector: selector asSymbol parameters: parameters asArray;
		returnType: returnType;
		start: patternStart; end: parameters last end
)
public parseLiteral ^<ExpressionAST> = (
	(* literal = pattern | number | symbolConstant | characterConstant | string | tuple. *)
	| n |

	tokenKind = #number ifTrue:
		[n:: NumberAST new
			value: tokenValue;
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].

	tokenKind = #binary ifTrue:
		[tokenValue = '-' ifTrue: [
			advanceToken.
			tokenKind = 'number' ifFalse: [expected: 'number'].
			n:: NumberAST new
				value: tokenValue * -1;
				start: tokenStart; end: tokenEnd.
		 	advanceToken.
		 	^n]].

	tokenKind = #symbol ifTrue:
		[n:: SymbolAST new
			value: tokenValue asSymbol;
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].

	tokenKind = #string ifTrue:
		[n:: StringAST new
			value: tokenValue asSymbol;
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].

	tokenKind = #character ifTrue:
		[n:: CharacterAST new
			value: tokenValue;
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].

	tokenKind = #'{' ifTrue:
		[^parseTuple].

	expected: 'literal'
)
public parseMessagePattern ^<MessagePatternAST> = (
	(* messagePattern = unaryMsgPattern | binaryMsgPattern | keywordMsgPattern. *)

	tokenKind = #identifier ifTrue:
		[^parseUnaryMessagePattern].
	tokenKind = #binary ifTrue:
		[^parseBinaryMessagePattern].
	tokenKind = #keyword ifTrue:
		[^parseKeywordMessagePattern].

	expected: 'message pattern'.
)
public parseMethodDeclaration ^<MethodAST> = (
	(* methodDecl = accessModifier opt, messagePattern, equalSign, lparen, codeBody, rparen. *)
	| declStart am pattern pragmas body declEnd |
	declStart:: extendedStart.
	am:: parseAccessModifierOpt.

	pattern:: parseMessagePattern.

	(tokenKind = #binary and: [tokenValue = '=']) ifFalse: [expected: '='].
	advanceToken.

	(tokenKind = #'(') ifFalse: [expected: '('].
	pragmas:: parsePragmaCommentOpt.
	advanceToken.

	body:: parseCodeBody.
	body pragmas: pragmas.

	(tokenKind = #')') ifFalse: [expected: ')'].
	declEnd:: tokenEnd.
	advanceToken.

	body parameters: pattern parameters. (* asList? *)
	^MethodAST new
		pattern: pattern body: body accessModifier: am;
		start: declStart; end: declEnd
)
public parseMethodDeclarationEnd ^<MethodAST> = (
	| result = parseMethodDeclaration. |
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseParameterDeclaration = (
	^parseVar
)
public parseParenthesizedExpression ^<ExpressionAST> = (
	(* parenthesizedExpression = lparen, expression, rparen. *)
	| start result |
	tokenKind = #'(' ifFalse: [expected: '('].
	start:: tokenStart.
	advanceToken.
	result:: parseExpression.
	tokenKind = #')' ifFalse: [expected: ')'].
	result start: start.
	result end: tokenEnd.
	advanceToken.
	^result
)
public parseParenthesizedTypeExpression = (
	(* parenthesizedTypeExpression = lparen, typeExpr, rparen *)
	| result |
	tokenKind = #'(' ifFalse: [expected: '('].
	advanceToken.
	result:: parseTypeExpression.
	tokenKind = #')' ifFalse: [expected: ')'].
	advanceToken.
	^result
)
public parsePragmaCommentOpt = (
	[ | comment subparser pragmas = List new. pragma |
	[skipWhitespace.
	 comment:: keepComment.
	 nil = comment] whileFalse:
		[subparser:: Parser for: comment.
		 pragma:: subparser advanceToken parsePragmaOpt.
		 nil = pragma ifFalse: [pragmas add: pragma]].
	pragmas isEmpty ifTrue: [^nil].
	^pragmas] on: Exception do: [:e | ^nil].
)
public parsePragmaOpt = (
	(* :pragma: unaryMessage | (keyword, literal)+ *)
	| selector arguments |
	tokenKind = #':' ifFalse: [^nil].
	advanceToken.
	tokenKind = #keyword ifFalse: [^nil].
	tokenValue = 'pragma:' ifFalse: [^nil].
	advanceToken.
	tokenKind = 'identifier' ifTrue:
		[^MessageAST new send: tokenValue asSymbol with: {}].

	selector:: ''.
	arguments:: List new.
	[tokenKind = #end] whileFalse:
		[tokenKind = #keyword ifFalse: [^nil].
		 selector:: selector, tokenValue.
		 advanceToken.
		 arguments add: parseLiteral].

	arguments isEmpty ifTrue: [^nil].
	^MessageAST new send: selector asSymbol with: arguments asArray
)
public parsePrimary ^<ExpressionAST> = (
	(* primary = slotName | literal | block | parenthesizedExpression. *)
	| send |

	tokenKind = #identifier ifTrue:
		[send:: unaryImplicitReceiverSend.
		 advanceToken.
		^send].

	tokenKind = #'[' ifTrue:
		[^parseClosure].

	tokenKind = #'(' ifTrue:
		[^parseParenthesizedExpression].

	^parseLiteral
)
public parseReturnStatement = (
	(* returnStatement = hat, expression, dot opt. *)
	| statementStart expression |
	tokenKind = #'^' ifFalse: [expected: '^'].
	statementStart:: tokenStart.
	advanceToken.
	expression:: parseExpression.
	tokenKind = '.' ifTrue: [advanceToken].
	^ReturnStatAST new
		expression: expression;
		start: statementStart; end: expression end
)
public parseReturnType = (
	tokenKind = '^' ifFalse: [expected: '^'].
	advanceToken.
	^parseType
)
public parseSendExpression ^<ExpressionAST> = (
	(* sendExpression = keywordHereSend | cascadedMessageExpression. *)
	peekHasKeywordMessage ifTrue: [^parseKeywordHereSend].
	^parseCascadedMessageExpression
)
public parseSlotDeclaration = (
	(* slotDef = accessModifier opt, slotDecl,
		(((tokenFromSymbol: #=) | (tokenFromSymbol: #'::=')), expression, dot) opt. *)
	| declStart am varStart varEnd varName type var init |
	declStart:: tokenStart.
	am:: parseAccessModifierOpt.
	var:: parseVar.

	tokenKind = #'::=' ifTrue:
		[advanceToken.
		 init:: parseSlotInitializer.
		 ^MutableSlotDefAST new
			accessModifier: am;
			slotDecl: var;
			initializer: init;
			start: declStart; end: init end].

	(tokenKind = #binary and: [tokenValue = '=']) ifTrue:
		[advanceToken.
		 init:: parseSlotInitializer.
		 ^ImmutableSlotDefAST new
			accessModifier: am;
			slotDecl: var;
			initializer: init;
			start: declStart; end: init end].

	^MutableSlotDefAST new
		accessModifier: am;
		slotDecl: var;
		initializer: nil;
		start: declStart; end: tokenEnd
)
public parseSlotInitializer ^<ExpressionAST> = (
	(* slotDef = accessModifier opt, slotDecl,
		(((tokenFromSymbol: #=) | (tokenFromSymbol: #'::=')), expression, dot) opt. *)
	| result |
	result:: parseExpression.
	tokenKind = #'.' ifFalse: [expected: '.'].
	advanceToken.
	^result
)
public parseStatements = (
	(*
	furtherStatements = dot, statements.
	statementSequence = expression, furtherStatements  opt.
 	statements = returnStatement | statementSequence | empty.
	*)
	| statements = List new. |

	[tokenKind = #'^' ifTrue:
		[statements add: parseReturnStatement.
		 ^statements].

	 (* ~FIRST(EXPRESSION) *)
	 tokenKind = #']' ifTrue: [^statements].
	 tokenKind = #')' ifTrue: [^statements].
	 tokenKind = #'}' ifTrue: [^statements].
	 tokenKind = #end ifTrue: [^statements].

	 statements add: parseExpression.
	 tokenKind = #'.' ifFalse: [^statements].
	 advanceToken] repeat.
)
public parseSuperclassClause = (
	(* superclassClause = superclassPrefix opt, identifier, message opt.
		outerReceiver = (tokenFromSymbol: #outer), identifier.
		superclassPrefix = outerReceiver | (tokenFromSymbol: #self) | (tokenFromSymbol: #super).
	*)
	| clauseStart sc clauseEnd message |

	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	clauseStart:: tokenStart.

	({'self'. 'super'. 'outer'} includes: tokenValue)
		ifFalse: [sc:: implicitReceiver]
		ifTrue:
			[sc:: VariableAST new name: tokenValue asSymbol; start: tokenStart; end: tokenEnd.
			 advanceToken.
			 sc name = #outer ifTrue:
				[tokenKind = #identifier ifFalse: [expected: 'identifier'].
				 sc:: UnresolvedSendAST new
					receiver: sc;
					message:
						(MessageAST new
							send: tokenValue asSymbol with: {};
							start: tokenStart; end: tokenEnd);
	                         start: clauseStart; end: tokenEnd.
				 advanceToken]].

	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	sc:: UnresolvedSendAST new
		receiver: sc;
		message:
			(MessageAST new
				send: tokenValue asSymbol with: {};
				start: tokenStart; end: tokenEnd);
		start: clauseStart; end: tokenEnd.
	clauseEnd:: tokenEnd.
	advanceToken.

	message:: parseSuperclassMessage.
	0 = message end ifFalse: [clauseEnd:: message end].

	^UnresolvedSendAST new
		receiver: sc;
		message: message;
		start: clauseStart; end: clauseEnd
)
public parseSuperclassMessage ^<MessageAST> = (
	tokenKind = #identifier ifTrue: [^parseUnaryMessage].
	tokenKind = #binary ifTrue: [^parseBinaryMessage].
	tokenKind = #keyword ifTrue: [^parseKeywordMessage].
	^MessageAST new send: #new with: {}
)
public parseTemporariesOpt ^<CodeBodyAST> = (
	| temps = List new. body |
	body:: CodeBodyAST new.
	body isSeq: true.
	body temporaries: temps.

	(* Also allow |||| as empty simultaneous slot declarations? *)

	(tokenKind = #binary and: [tokenValue = '||']) ifTrue:
		[advanceToken.
		 tokenKind = #identifier ifFalse: [^body].
		 body isSeq: false.
		 [tokenKind = #binary and: [tokenValue = '||']] whileFalse:
			[temps add: parseSlotDeclaration].
		 advanceToken. (* || *)
		 ^body].

	(tokenKind = #binary and: [tokenValue = '|']) ifTrue:
		[advanceToken.
		[tokenKind = #binary and: [tokenValue = '|']] whileFalse:
			[temps add: parseSlotDeclaration].
		 advanceToken. (* | *)
		 ^body].

	^body (* No temporaries. *)
)
public parseTransientSlotDeclaration = (
	(* transientSlotDecl = accessModifier opt, transientModifier, slotDecl, ((tokenFromSymbol: #=) | (tokenFromSymbol: #'::=')), expression, dot. *)
	| declStart declEnd am var isMutable init |
	declStart:: extendedStart.
	am:: parseAccessModifierOpt.

	(tokenKind = #identifier and: [tokenValue = 'transient']) ifFalse: [expected: 'transient'].
	advanceToken.

	var:: parseVar.

	tokenKind = #'::='
		ifTrue: [isMutable:: true]
		ifFalse:
			[(tokenKind = #binary and: [tokenValue = '='])
				ifTrue: [isMutable:: false]
				ifFalse: [expected: '= or ::=']].
	advanceToken.

	init:: parseExpression.
	tokenKind = #'.' ifFalse: [expected: '.'].
	declEnd:: tokenEnd.
	advanceToken.

	^(isMutable ifTrue: [MutableSlotDefAST] ifFalse: [ImmutableSlotDefAST]) new
		accessModifier: am;
		slotDecl: var;
		initializer: init;
		start: declStart; end: declEnd
)
public parseTransientSlotDeclarationEnd = (
	| result = parseTransientSlotDeclaration. |
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseTuple ^<TupleAST> = (
	(* tuple = lcurly, (expression starSeparatedOrTerminatedBy: dot), rcurly. *)
	| tupleStart tupleEnd elements = List new. |

	tokenKind = #'{' ifFalse: [expected: '{'].
	tupleStart:: tokenStart.
	advanceToken.

	[tokenKind = #'}'] whileFalse:
		[elements add: parseExpression.
		 tokenKind = #'.' ifTrue: [advanceToken]].

	tupleEnd:: tokenEnd.
	advanceToken. (* Consume } *)

	^TupleAST new elements: elements; start: tupleStart; end: tupleEnd
)
public parseTupleType = (
	(* tupleType = lcurly, (typeExpr starSeparatedBy: dot), rcurly *)
	tokenKind = #'{' ifFalse: [expected: '{'].
	advanceToken.
	[tokenKind = #'}'] whileFalse:
		[parseTypeExpression.
		 tokenKind = #'.' ifTrue: [advanceToken]].
	advanceToken. (* Consume } *)
	^nil
)
public parseType = (
	| type |
	(tokenKind = #binary and: [tokenValue = '<']) ifFalse:
		[expected: '<'].
	advanceToken.
	type:: parseTypeExpression.
	(tokenKind = #binary and: [tokenValue = '>']) ifFalse:
		[expected: '<'].
	advanceToken.
	^type
)
public parseTypeArgumentsOpt = (
	(* typeArguments = lbracket, (typeExpr plusSeparatedBy: comma), rbracket *)
	tokenKind = #'[' ifFalse: [^nil].
	advanceToken.
	[parseTypeExpression.
	 tokenKind = #binary and: [tokenValue = ',']]
		whileTrue: [advanceToken].
	tokenKind = #']' ifFalse: [expected: ']'].
	advanceToken.
	^nil
)
public parseTypeExpression = (
	(* typeExpr = typeTerm, ((vbar | semicolon | slash), typeExpr) *)
	[parseTypeTerm.
	 peekHasTypeOperator]
		whileTrue: [advanceToken].
	^nil
)
public parseTypeFactor = (
	(* typeFactor = typePrimary | blockType | tupleType | parenthesizedTypeExpression *)
	tokenKind = #'[' ifTrue: [^parseClosureType].
	tokenKind = #'{' ifTrue: [^parseTupleType].
	tokenKind = #'(' ifTrue: [^parseParenthesizedTypeExpression].
	^parseTypePrimary
)
public parseTypePrimary = (
	(* typePrimary = identifier, typeArguments opt *)
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	advanceToken.
	parseTypeArgumentsOpt.
	^nil
)
public parseTypeTerm = (
	(* typeTerm = typeFactor, identifier star *)
	parseTypeFactor.
	[tokenKind = #identifier]
		whileTrue: [advanceToken].
	^nil
)
public parseUnaryExpression ^<ExpressionAST> = (
	(* unaryExpression = primary, unaryMsg star. *)
	| result message |

	result:: parsePrimary.

	[peekHasUnaryMessage] whileTrue:
		[message:: parseUnaryMessage.
		 result:: UnresolvedSendAST new
			to: result send: message;
			start: result start; end: message end].

	^result
)
public parseUnaryMessage ^<MessageAST> = (
	(* unaryMsg = eventualSendOperator opt, unarySelector. *)
	| messageStart isEventual message |

	messageStart:: tokenStart.
	isEventual:: tokenKind = #'<-:'.
	isEventual ifTrue: [advanceToken].

	tokenKind = #identifier ifFalse: [expected: 'unary selector'].

	message:: MessageAST new
		send: tokenValue asSymbol with: {};
		isEventual: isEventual;
		start: messageStart; end: tokenEnd.
	advanceToken.
	^message
)
public parseUnaryMessagePattern ^<MessagePatternAST> = (
	(* unaryMsgPattern = unarySelector. *)
	| pattern |

	tokenKind = #identifier ifFalse: [expected: 'unary selector'].

	pattern:: MessagePatternAST new
		selector: tokenValue asSymbol parameters: {};
		start: tokenStart; end: tokenEnd.
	advanceToken.

	tokenKind = #'^' ifTrue: [pattern returnType: parseReturnType].

	^pattern
)
public parseVar = (
	| start end name type |
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	start:: tokenStart.
	end:: tokenEnd.
	name:: tokenValue asSymbol.
	advanceToken.
	(tokenKind = #binary and: [tokenValue = '<']) ifTrue:
		[type: parseType].
	^(VarDeclAST name: name type: type)
		start: start; end: end.
)
peekHasAccessModifier ^<Boolean> = (
	(* LL(1) *)
	tokenKind = #identifier ifFalse: [^false].
	tokenValue = #public ifTrue: [^true].
	tokenValue = #protected ifTrue: [^true].
	tokenValue = #private ifTrue: [^true].
	^false
)
peekHasBinaryMessage ^<Boolean> = (
	(* LL(2) *)
	| context result |
	tokenKind = #binary ifTrue: [^true].
	tokenKind = #'<-:' ifFalse: [^false].

	(* Unlikely *)
	context:: saveContext.
	advanceToken. (* Consume <-: *)
	result:: tokenKind = #binary.
	restoreContext: context.
	^result
)
peekHasClassDeclaration ^<Boolean> = (
	(* LL(3) *)
	(* classHeader = (accessModifier opt, (tokenFromSymbol: #class), identifier, ... *)

	| context = saveContext. |
	peekHasAccessModifier ifTrue: [advanceToken].

	(tokenKind = #identifier and: [tokenValue = 'class']) ifFalse:
		[restoreContext: context.
		 ^false].
	advanceToken.

	tokenKind = #identifier ifFalse:
		[restoreContext: context.
		 ^false].

	restoreContext: context.
	^true
)
peekHasKeywordMessage ^<Boolean> = (
	(* LL(2) *)
	| context result |
	tokenKind = #keyword ifTrue: [^true].
	tokenKind = #'<-:' ifFalse: [^false].

	(* Unlikely *)
	context:: saveContext.
	advanceToken. (* Consume <-: *)
	result:: tokenKind = #keyword.
	restoreContext: context.
	^result
)
peekHasTransientSlotDeclaration ^<Boolean> = (
	(* LL(3) *)
	(* transientSlotDecl = (accessModifier opt, (tokenFromSymbol: #transient), identifier, ... *)

	| context = saveContext. |
	peekHasAccessModifier ifTrue: [advanceToken].

	(tokenKind = #identifier and: [tokenValue = 'transient']) ifFalse:
		[restoreContext: context.
		 ^false].

	advanceToken.

	tokenKind = #identifier ifFalse:
		[restoreContext: context.
		 ^false].

	restoreContext: context.
	^true
)
peekHasTypeOperator ^<Boolean> = (
	(* LL(1) *)
	tokenKind = #binary ifFalse: [^false].
	tokenValue = '|' ifTrue: [^true].
	tokenValue = ';' ifTrue: [^true].
	tokenValue = '/' ifTrue: [^true].
	^false
)
peekHasUnaryMessage ^<Boolean> = (
	(* LL(2) *)
	| context result |
	tokenKind = #identifier ifTrue: [^true].
	tokenKind = #'<-:' ifFalse: [^false].

	(* Unlikely *)
	context:: saveContext.
	advanceToken. (* Consume <-: *)
	result:: tokenKind = #identifier.
	restoreContext: context.
	^result
)
unaryImplicitReceiverSend = (
	| selector = tokenValue asSymbol. message |
	selector = #self ifFalse:
		[selector = #super ifFalse:
			[selector = #outer ifFalse:
				[message:: MessageAST new
					send: selector with: {};
					start: tokenStart; end: tokenEnd.
				^UnresolvedSendAST new
					to: implicitReceiver send: message;
	                	start: tokenStart; end: tokenEnd]]].

	^VariableAST new name: selector; start: tokenStart; end: tokenEnd.
)
) : (
)
(* Turns Newspeak source into a stream of tokens.

The current token is available via #tokenKind, #tokenValue, #tokenStart, and #tokenEnd.

Frequency of Newspeak tokens:

#identifier 137832
#keyword 57744
#binary 54283
#'.' 25339
#'(' 23920
#')' 23920
#'[' 12090
#']' 12090
#'^' 11228
#number 10767
#string 6080
#setter 5520
#':' 5172
#';' 2253
#symbol 2015
#'{' 1477
#'}' 1477
#character 500
#'::=' 497
#'<-:' 161

*)
public class Scanner for: string = (
	|
	private input <String> = string.
	private size <Integer> = string size.
	private position <Integer> ::= 1. (* Index of the next rune to scan. *)

	public tokenStart <Integer> ::= 0.
	public tokenKind <Symbol>
	public tokenValue (* The evaluated token, not it's substring in the source. *)
	public extendedStart <Integer>
	|
) (
public advanceToken = (
	| byte |
	skipWhitespaceAndComments.
	tokenStart:: position.
	tokenValue:: nil.
	position <= size ifFalse:
		[tokenKind:: #end.
		 ^self].
	byte:: input at: position.
	position:: position + 1.

	(isLetterOrUnderscore: byte) ifTrue:
		[^self scanIdentifierOrKeyword].
	(isSpecialCharacter: byte) ifTrue:
		[^self scanBinarySelector].
	(isDecimalDigit: byte) ifTrue:
		[^self scanNumber].

	byte = 58 ifTrue: [
		position + 1 <= size ifTrue:
			[(input at: position) = 58 ifTrue:
				[(input at: position + 1) = 61 ifTrue:
					[position:: position + 2.
					 tokenKind:: #'::='.
					 ^self]]].
		tokenKind:: #':'.
		^self].

	byte = 34 ifTrue: [^self scanStringDouble].
	byte = 35 ifTrue: [^self scanSymbol].
	byte = 36 ifTrue: [^self scanCharacter].
	byte = 39 ifTrue: [^self scanStringSingle].
	byte = 40 ifTrue: [tokenKind:: #'('. ^self].
	byte = 41 ifTrue: [tokenKind:: #')'. ^self].
	byte = 46 ifTrue: [tokenKind:: #'.'. ^self].
	byte = 59 ifTrue: [tokenKind:: #';'. ^self].
	byte = 91 ifTrue: [tokenKind:: #'['. ^self].
	byte = 93 ifTrue: [tokenKind:: #']'. ^self].
	byte = 94 ifTrue: [tokenKind:: #'^'. ^self].
	byte = 123 ifTrue: [tokenKind:: #'{'. ^self].
	byte = 125 ifTrue: [tokenKind:: #'}'. ^self].

	scanError: 'Unknown token'.
)
private extendedDigitValue: byte <Integer> ^<Integer> = (
	byte <= 57 ifTrue: [^byte - 48].
	^byte - 55
)
private isAlphanumOrUnderscore: byte <Integer> ^<Boolean> = (
	byte >= 97 ifTrue: [byte <= 122 ifTrue: [^true]].
	byte >= 65 ifTrue: [byte <= 90 ifTrue: [^true]].
	byte >= 48 ifTrue: [byte <= 57 ifTrue: [^true]].
	^byte = 95
)
private isDecimalDigit: byte <Integer> ^<Boolean> = (
	byte >= 48 ifTrue: [byte <= 57 ifTrue: [^true]].
	^false
)
private isExtendedDigit: byte <Integer> ^<Boolean> = (
	byte >= 48 ifTrue: [byte <= 57 ifTrue: [^true]].
	byte >= 65 ifTrue: [byte <= 90 ifTrue: [^true]].
	^false
)
private isHexDigit: byte <Integer> ^<Boolean> = (
	byte >= 48 ifTrue: [byte <= 57 ifTrue: [^true]].
	byte >= 65 ifTrue: [byte <= 70 ifTrue: [^true]].
	^false
)
private isLetterOrUnderscore: byte <Integer> ^<Boolean> = (
	byte >= 97 ifTrue: [byte <= 122 ifTrue: [^true]].
	byte >= 65 ifTrue: [byte <= 90 ifTrue: [^true]].
	^byte = 95
)
private isSpecialCharacter: byte <Integer> ^<Boolean> = (
	byte = 33 ifTrue: [^true]. (* ! *)
	byte = 37 ifTrue: [^true]. (* % *)
	byte = 38 ifTrue: [^true]. (* & *)
	byte = 42 ifTrue: [^true]. (* * *)
	byte = 43 ifTrue: [^true]. (* + *)
	byte = 44 ifTrue: [^true]. (* , *)
	byte = 45 ifTrue: [^true]. (* - *)
	byte = 47 ifTrue: [^true]. (* / *)
	byte = 60 ifTrue: [^true]. (* < *)
	byte = 61 ifTrue: [^true]. (* = *)
	byte = 62 ifTrue: [^true]. (* > *)
	byte = 63 ifTrue: [^true]. (* ? *)
	byte = 64 ifTrue: [^true]. (* @ *)
	byte = 92 ifTrue: [^true]. (* \ *)
	byte = 124 ifTrue: [^true]. (* | *)
	byte = 126 ifTrue: [^true]. (* ~ *)
	^false
)
public keepComment ^<String> = (
	| commentStart |
	skipWhitespace.
	commentStart:: position.
	skipComment ifFalse: [^nil].
	^input copyFrom: commentStart + 2 to: position - 1 - 2
)
private keepComment: comments <List[{String.String}]> = (
	| tag payloadStart payloadEnd |
	position + 1 <= size ifFalse: [^self].
	(input at: position) = 40 (* ( *) ifFalse: [^self].
	(input at: position + 1) = 42 (* * *) ifFalse: [^self].
	position:: position + 2.

	tag:: scanMetadataTag.
	payloadStart:: position.

	[position + 1 <= size] whileTrue:
		[(* End of comment. *)
		(input at: position) = 42 (* * *) ifTrue:
			[(input at: position + 1) = 41 (* ) *) ifTrue:
				[payloadEnd:: position - 1.
				 position: position + 2.
				 comments add: {tag. input copyFrom: payloadStart to: payloadEnd}.
				 ^self]].

		(* Nested comment. *)
		(input at: position) = 40 (* ( *) ifTrue:
			[(input at: position + 1) = 42 (* * *) ifTrue:
				[skipComment.
				 position:: position - 1]].

		position:: position + 1].

	scanError: 'Unterminated comment'
)
public keepComments ^<List[{String.String}]> = (
	| result = List new. |
	[ | p = position. |
	 skipWhitespace.
	 keepComment: result.
	 p = position] whileFalse.
	^result
)
private peekHasRadix ^<Boolean> = (
	position + 1 <= size ifFalse: [^false].
	(input at: position) = 114 ifFalse: [^false].
	^isExtendedDigit: (input at: position + 1)
)
protected restoreContext: context = (
	position:: context.
	advanceToken.
)
protected saveContext = (
	^extendedStart
)
private scanBinarySelector = (
	[position <= size ifFalse: [false] ifTrue: [isSpecialCharacter: (input at: position)]]
		whileTrue: [position:: position + 1].

	tokenValue:: input copyFrom: tokenStart to: position - 1.
	tokenKind:: #binary.

	(* Check for a longer match as the eventual send operator. *)
	tokenValue = #'<-' ifFalse: [^self].
	position <= size ifFalse: [^self].
	(input at: position) = 58 ifTrue:
		[position:: position + 1.
		 tokenValue:: nil.
		 tokenKind:: #'<-:'].
)
private scanCharacter = (
	| byte |
	position > size ifTrue:
		[scanError: 'Unterminated character literal'].
	tokenKind:: #character.
	byte:: input at: position.
	92 = byte
		ifTrue: [tokenValue:: scanEscape]
		ifFalse: [tokenValue:: byte].
	position:: 1 + position.
)
private scanError: message = (
	^(ParseError message: message position: position) signal
)
private scanEscape = (
	| byte |
	position < size ifFalse:
		[scanError: 'Unterminated escape sequence'].
	position:: 1 + position.
	byte:: input at: position.
	98 = byte ifTrue: [^8].  (* \b *)
	116 = byte ifTrue: [^9].  (* \t *)
	110 = byte ifTrue: [^10]. (* \n *)
	102 = byte ifTrue: [^12]. (* \f *)
	114 = byte ifTrue: [^13]. (* \r *)
	34 = byte ifTrue: [^34].  (* \" *)
	39 = byte ifTrue: [^39].  (* \' *)
	92 = byte ifTrue: [^92].  (* \\ *)
	120 = byte ifTrue: [^scanStringHexEscape].
	scanError: 'Invalid escape sequence'
)
private scanIdentifierOrKeyword = (
	|
	pos ::= position.
	in = input.
	sz = size.
	|
	[pos <= sz ifFalse: [false] ifTrue: [isAlphanumOrUnderscore: (in at: pos)]]
		whileTrue: [pos:: pos + 1].

	pos <= sz ifTrue:
		[(in at: pos) = 58 ifTrue:
			[tokenValue:: in copyFrom: tokenStart to: pos.
			 pos + 1 <= sz ifTrue:
				[(input at: pos + 1) = 58 ifTrue:
					[position:: pos + 2.
					 tokenKind:: #setter.
					 ^self]].
			position:: pos + 1.
			tokenKind:: #keyword.
			^self]].

	position:: pos.
	tokenValue:: input copyFrom: tokenStart to: pos - 1.
	tokenKind:: #identifier.
)
private scanMaybeExponent ^<Integer> = (
	| neg exp byte |
	position + 1 <= size ifFalse: [^1].
	(input at: position) = 101 ifFalse: [^1].

	neg:: (input at: position + 1) = 45.
	neg
		ifTrue:
			[position + 2 <= size ifFalse: [^1].
			 (isDecimalDigit: (input at: position + 2)) ifFalse: [^1].
			 position:: position + 2 (* Consume 'e-' *)]
		ifFalse:
			[(isDecimalDigit: (input at: position + 1)) ifFalse: [^1].
			 position:: position + 1 (* Consume 'e' *)].

	exp:: 0.
	[position <= size and: [isDecimalDigit: (byte:: input at: position)]]
		whileTrue:
			[exp:: exp * 10 + (byte - 48).
			 position:: position + 1].

	neg ifTrue: [exp:: exp * -1].
	^10 raisedTo: exp
)
private scanMaybeFraction: radix <Integer> ^<Fraction> = (
	| numerator denominator byte digit |

	position + 1 <= size ifFalse: [^0].
	(input at: position) = 46 ifFalse: [^0].
	(isExtendedDigit: (input at: position + 1)) ifFalse: [^0].

	numerator:: 0.
	denominator:: 1.
	position:: position + 1. (* Consume '.' *)
	[position <= size and: [isExtendedDigit: (byte:: input at: position)]]
		whileTrue:
			[digit:: extendedDigitValue: byte.
			 digit < radix ifFalse: [scanError: 'Digit exceeds radix'].
			 numerator:: numerator * radix + digit.
			 denominator:: denominator * radix.
			 position:: position + 1].

	^numerator / denominator
)
scanMetadataTag = (
	|
	pos ::= position.
	in = input.
	sz = size.
	startTag
	endTag
	|

	[pos <= sz
		ifFalse: [false]
		ifTrue: [(in at: pos) <= 32]] whileTrue:
			[pos:: pos + 1].

	pos <= sz ifFalse: [^nil].
	(in at: pos) = 58 (* : *) ifFalse: [^nil].
	pos:: pos + 1.

	(isLetterOrUnderscore: (in at: pos)) ifFalse: [^nil].
	startTag:: pos.
	pos:: pos + 1.
	[pos <= sz
		ifFalse: [false]
		ifTrue: [isAlphanumOrUnderscore: (in at: pos)]] whileTrue:
			[pos:: pos + 1].
	endTag:: pos - 1.

	pos <= sz ifFalse: [^nil].
	(in at: pos) = 58 (* : *) ifFalse: [^nil].
	position:: pos + 1.
	^in copyFrom: startTag to: endTag
)
private scanNumber = (
	(* '-'? decdigits+ [. decdigits?] ['e' '-'?' decdigit+] *)
	(* decdigit+ 'r' '-'? hexdigits+ [. hexdigits?] ['e' '-'?' decdigit+] *)

	| val byte radix digit |
	val:: (input at: position - 1) - 48.

	[position <= size ifFalse: [false] ifTrue: [isDecimalDigit: (byte:: input at: position)]]
		whileTrue:
			[val:: val * 10 + (byte - 48).
			 position:: position + 1].

	radix:: 10.
	peekHasRadix ifTrue:
		[radix:: val.
		 val:: 0.
		 position:: position + 1. (* Consume "r" *)
		 [position <= size and: [isExtendedDigit: (byte:: input at: position)]]
			whileTrue:
				[digit:: extendedDigitValue: byte.
				 digit < radix ifFalse: [scanError: 'Digit exceeds radix'].
				 val:: val * radix + digit.
				 position:: position + 1]].

	val:: val + (scanMaybeFraction: radix).
	val:: val * scanMaybeExponent.

	tokenKind:: #number.
	tokenValue:: val.
)
private scanStringDouble = (
	| bytes = List new. byte |
	tokenKind:: #string.
	[position <= size] whileTrue:
		[byte:: input at: position.
		 34 = byte ifTrue:
			[position:: 1 + position.
			 tokenValue:: String withAll: bytes.
			 ^self].
		 92 = byte ifTrue:
			[byte:: scanEscape].
		bytes add: byte.
		position:: 1 + position].
	scanError: 'Unterminated string literal'
)
private scanStringHexEscape = (
	| low high |
	position + 2 <= size ifFalse:
		[scanError: 'Unterminated string escape'].

	high:: input at: 1 + position.
	(isHexDigit: high) ifFalse:
		[scanError: 'Invalid string escape'].
	high:: extendedDigitValue: high.

	low:: input at: 2 + position.
	(isHexDigit: low) ifFalse:
		[scanError: 'Invalid string escape'].
	low:: extendedDigitValue: low.

	position:: 2 + position.
	^high << 4 | low
)
private scanStringSingle = (
	| bytes = List new. byte |
	tokenKind:: #string.
	[position <= size] whileTrue:
		[(byte:: input at: position) = 39 ifTrue:
			[position:: position + 1.
			 position <= size ifFalse:
				[tokenValue:: String withAll: bytes. ^self].
			(input at: position) = 39 ifFalse:
				[tokenValue:: String withAll: bytes. ^self].
			(* Escaped single quote *)].
		bytes add: byte.
		position:: position + 1].

	scanError: 'Unterminated string literal'
)
private scanSymbol = (
	| byte |
	position <= size ifFalse:
		[scanError: 'Unterminated symbol literal'].
	byte:: input at: position.
	position:: position + 1.
	byte = 34 ifTrue:
		[self scanStringDouble.
		 tokenKind:: #symbol.
		 ^self].
	byte = 39 ifTrue:
		[self scanStringSingle.
		 tokenKind:: #symbol.
		 ^self].
	(isSpecialCharacter: byte) ifTrue:
		[self scanBinarySelector.
		 tokenKind:: #symbol.
		 tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
		 ^self].

	(isLetterOrUnderscore: byte) ifTrue:
		[^scanSymbolUnaryOrKeyword].

	scanError: 'Invalid symbol literal'
)
private scanSymbolUnaryOrKeyword = (
	tokenKind:: #symbol.
	[position <= size and: [isAlphanumOrUnderscore: (input at: position)]]
		whileTrue: [position:: position + 1].

	position <= size ifFalse:
		[tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
		 ^self].

	(input at: position) = 58 ifFalse:
		[tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
		 ^self].
	position:: position + 1. (* Consume : *)

	(* Keyword selector *)
	[position <= size and: [isAlphanumOrUnderscore: (input at: position)]]
		whileTrue:
			[[position <= size and: [isAlphanumOrUnderscore: (input at: position)]]
				whileTrue: [position:: position + 1].
			 position <= size ifFalse:
				[scanError: 'Unterminated symbol literal'].
			 (input at: position) = 58 ifFalse:
				[scanError: 'Unterminated symbol literal'].
			 position:: position + 1 (* Consume : *)].

	tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
)
private skipComment = (
	position + 1 <= size ifFalse: [^false].
	(input at: position) = 40 (* ( *) ifFalse: [^false].
	(input at: position + 1) = 42 (* * *) ifFalse: [^false].
	nil = extendedStart ifTrue: [extendedStart:: position].
	position:: position + 2.

	[position + 1 <= size] whileTrue:
		[(* End of comment. *)
		(input at: position) = 42 (* * *) ifTrue:
			[(input at: position + 1) = 41 (* ) *) ifTrue:
				[position: position + 2. ^true]].

		(* Nested comment. *)
		(input at: position) = 40 (* ( *) ifTrue:
			[(input at: position + 1) = 42 (* * *) ifTrue:
				[skipComment.
				 position:: position - 1]].

		position:: position + 1].

	scanError: 'Unterminated comment'
)
protected skipWhitespace = (
	[position <= size] whileTrue:
		[(input at: position) <= 32 ifFalse: [^self].
		 position:: position + 1].
)
private skipWhitespaceAndComments = (
	extendedStart:: nil.
	[ | p = position. |
	 skipWhitespace.
	 skipComment.
	 p = position] whileFalse.
	nil = extendedStart ifTrue:
		[extendedStart:: position].
)
public tokenEnd ^<Integer> = (
	^position - 1
)
) : (
)
) : (
)
