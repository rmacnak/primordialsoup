(* Reflection. *)
(* :exemplar: platform mirrors *)
class Mirrors usingPlatform: platform internalKernel: ik namespace: ns = (|
private Collection = platform collections Collection.
private List = platform collections List.
private Map = platform collections Map.
private Set = platform collections Set.
private WeakArray = platform kernel WeakArray.
private WeakMap = platform kernel WeakMap.
private StringBuilder = platform kernel StringBuilder.
private ArgumentError = ik ArgumentError.
private IdentityMap = ik IdentityMap.
private InstanceMixin = ik InstanceMixin.
private ClassMixin = ik ClassMixin.
private Metaclass = ik Metaclass.

private Activation = ik Activation.
private Closure = ik Closure.
private Message = ik Message.
private String = ik String.

private reflectees = WeakMap new.

private cachedPlatform = platform.
private internalKernel = ik.
private namespace = ns.
private parsingX
private intermediatesX
private compilerX
|) (
public class ActivationMirror reflecting: activation thread: thr = (
(* :bogus: This constructor should not be public. *)
	|
	private reflectee <Activation> = activation.
	private thread <Thread> = thr.
	|
	reflectees at: self put: activation
) (
public = other ^<Boolean> = (
	(is: reflectee identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfActivationMirror
)
public closure ^<ObjectMirror> = (
	| rawClosure = reflectee closure. |
	nil = rawClosure ifTrue: [^nil].
	^ObjectMirror reflecting: rawClosure
)
private compileExpression: expression <String> with: rawScope <Map[Symbol, Object]> ^<Method> = (
	| mixinMirror imethod |
	(* Super, outer and implicit receiver sends should behave like the expression is in the method class, not the receiver class. *)
	mixinMirror:: method definingMixin.
	imethod:: compiler
		compileExpressionSource: expression
		debugMapper: computeDebugMapper
		withScope: rawScope
		inMixin: mixinMirror.

	imethod methodMixin: reflectee method mixin.
	imethod source: expression.
	imethod debugInfo source: expression.
	^imethod compiledMethod metadata: imethod debugInfo
)
private computeDebugMapper = (
	^(computeDebugInfo: reflectee method) mapperForContext: reflectee
)
public enclosingActivation ^<ActivationMirror> = (
	| rawEnclosing = reflectee enclosingActivation. |
	nil = rawEnclosing ifTrue: [^nil].
	^ActivationMirror reflecting: rawEnclosing thread: thread
)
public evaluate: expression <String> ^<ThreadMirror> = (
	^(evaluateSuspended: expression) resume
)
public evaluate: expression <String> with: scope <Map[Symbol, ObjectMirror]> ^<ThreadMirror> = (
	^(evaluateSuspended: expression with: scope) resume
)
public evaluateSuspended: expression <String> ^<ThreadMirror> = (
	^evaluateSuspended: expression with: Map new
)
public evaluateSuspended: expression <String> with: scope <Map[Symbol, ObjectMirror]> ^<ThreadMirror> = (
	| rawScope expressionMethod thread simulator |
	rawScope:: Map new.
	scope keysAndValuesDo: [:key :value | rawScope at: key put: (reflectees at: value)].
	expressionMethod:: compileExpression: expression with: rawScope.

	simulator:: Simulator new.
	simulator activate: expressionMethod receiver: reflectee receiver arguments: {reflectee. rawScope}.

	thread:: Thread new.
	thread state: #suspended.
	thread suspendedActivation: simulator activation.

	^ThreadMirror reflecting: thread
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) bitXor: class hash
)
public isKindOfActivationMirror ^<Boolean> = (
	^true
)
public isUncontinuable ^<Boolean> = (
	^reflectee isDead
)
public method ^<MethorMirror> = (
	| rawMethod = reflectee method. definingMixin |

	(* Regular method / expression *)
	rawMethod isSynthetic ifFalse:
		[^MethodMirror reflecting: rawMethod].

	(* :todo: These tests are complicated, and might also be wrong if the mixin was changed after this activation. Consider saving the relevant InstanceMixin in the synthetic method's metadata slot in the original compile instead. *)

	definingMixin:: rawMethod mixin.
	definingMixin isMeta ifFalse:
		[(* Nested class accessor *)
		 definingMixin _nestedMixins do:
			[:nestedMixin | nestedMixin _name = rawMethod selector ifTrue:
				[^SyntheticMethodMirror
					reflecting: rawMethod
					name: rawMethod selector
					source: nestedMixin _headerSource]].
		 (* Instance initializer *)
		 (isSubinitializerSelector: rawMethod selector) ifTrue:
			[^SyntheticMethodMirror
				reflecting: rawMethod
				name: definingMixin _primaryFactorySelector
				source: definingMixin _headerSource].
		 (* Transient slot getter / setter / initializer *)
		 definingMixin _slots do:
			[:slot | slot isTransient ifTrue:
				[ |
				  getterName = demangleTransientSlotName: slot name.
				  setterName = getterName, ':'.
				  initName = getterName, '`init'.
				  source = slot metadata.
				  |
				rawMethod selector = getterName ifTrue:
					[^SyntheticMethodMirror
						reflecting: rawMethod
						name: getterName
						source: source].
				rawMethod selector = setterName ifTrue:
					[^SyntheticMethodMirror
						reflecting: rawMethod
						name: setterName
						source: source].
				rawMethod selector = initName ifTrue:
					[^SyntheticMethodMirror
						reflecting: rawMethod
						name: getterName
						source: source]]]].

	(* Factory *)
	definingMixin isMeta ifTrue:
		[definingMixin _instanceMixin _primaryFactorySelector = rawMethod selector ifTrue:
			[^SyntheticMethodMirror
				reflecting: rawMethod
				name: rawMethod selector
				source: definingMixin _instanceMixin _headerSource]].

	panic.
)
public operands ^<List[ObjectMirror]> = (
	(* todo: Should these simply appear in `slots` as slots with an empty or nil name? *)
	(* 'stack'? 'expression stack'? 'operand stack'? *)
	| closure numTemps result |
	closure:: reflectee closure.
	nil = closure
		ifTrue: [numTemps:: reflectee method numTemps]
		ifFalse: [numTemps:: closure numArgs + (numCopiedOf: closure)].
	result:: List new.
	numTemps + 1 to: reflectee size do:
		[:index | result add: (ObjectMirror reflecting: (reflectee tempAt: index))].
	^result
)
public receiver ^<ObjectMirror> = (
	^ObjectMirror reflecting: reflectee receiver
)
public restart ^<ThreadMirror> = (
	thread restart: reflectee withLookup: false.
	^ThreadMirror reflecting: thread
)
public restartWithLookup ^<ThreadMirror> = (
	thread restart: reflectee withLookup: true.
	^ThreadMirror reflecting: thread
)
public return: result <ObjectMirror> ^<ThreadMirror> = (
	thread return: (reflectees at: result) from: reflectee.
	^ThreadMirror reflecting: thread
)
public sender ^<ActivationMirror> = (
	| rawSender = reflectee sender. |
	nil = rawSender ifTrue: [^nil].
	rawSender method primitive = 163 ifTrue: [^nil (* Hide simulation root. *)].
	^ActivationMirror reflecting: rawSender thread: thread
)
public slots ^<List[SlotMirror]> = (
	| mapper = computeDebugMapper. result = List new. |
	mapper localsDo:
		[:name :value |
		 result add: (SlotMirror
			name: name
			value: (ObjectMirror reflecting: value))].
	^result
)
public sourceRange ^<Interval> = (
	(* The bci of an activation points to the bytecode that will be executed next. For the top activation, we want the source range to be this next action. For other activations, we want the source interval to be the pending message send. *)
	| method <Method> effectiveBCI <Integer> range <Interval> |
	method:: reflectee method.
	effectiveBCI:: reflectee bci.
	reflectee = thread suspendedActivation ifFalse:
		[effectiveBCI:: Simulator bciBefore: effectiveBCI in: method].
	range:: (computeDebugInfo: method) bciSourceMapping at: effectiveBCI ifAbsent: [^nil].
	range start = 0 ifTrue: [^nil].
	^range
)
public stepInto ^<ThreadMirror> = (
	thread stepInto: reflectee.
	^ThreadMirror reflecting: thread
)
public stepOut ^<ThreadMirror> = (
	thread stepOut: reflectee.
	^ThreadMirror reflecting: thread
)
public stepOver ^<ThreadMirror> = (
	thread stepOver: reflectee.
	^ThreadMirror reflecting: thread
)
public stepThrough ^<ThreadMirror> = (
	thread stepThrough: reflectee.
	^ThreadMirror reflecting: thread
)
) : (
public invokeSuspended: closure = (
	| simulator thread |

	Closure = (classOf: closure) ifFalse: [^(ArgumentError value: closure) signal].
	closure numArgs = 0 ifFalse: [^(ArgumentError value: closure) signal].

	simulator:: Simulator new.
	simulator activateClosure: closure arguments: {}.

	thread:: Thread new.
	thread state: #suspended.
	thread suspendedActivation: simulator activation.

	^ThreadMirror reflecting: thread
)
)
class AtomicInstaller = (|
private updateMixinsAndClasses <IdentityMap[OldObject,NewObject]>
private updateInstances <IdentityMap[OldObject,NewObject]>
private existingClasses <IdentityMap[HierarchyDepth,Set[Class]]>
private newExistingMixins <Map[IntermediateClassDeclaration,InstanceMixin]>
|) (
allInstVarNamesOf: cls = (
	nil = cls ifTrue: [^{}].
	^(allInstVarNamesOf: (superclassOf: cls)) , ((mixinOf: cls) _slots collect: [:slot | slot name])
)
private cleanup = (
	updateMixinsAndClasses: nil.
	updateInstances: nil.
	existingClasses: nil.
	newExistingMixins: nil.
)
private depthFor: klassArg <Class> ^<Integer> = (
	| klass depth |
	depth: 0.
	klass: klassArg.
	[nil = klass] whileFalse:
		[klass:: superclassOf: klass.
		depth: depth + 1].
	^depth
)
in: collection lastIndexOf: element = (
	collection size to: 1 by: -1 do: [:index | (collection at: index) = element ifTrue: [^index]].
	^0
)
public install: classDecls <List[IntermediateClassDeclaration]> = (
	| results |
	setup.
	results:: classDecls collect: [:classDecl | processClassDeclaration: classDecl].
	processExistingClasses.
	installAll.
	newExistingMixins keysAndValuesDo:
		[:classDecl :mixin | classDecl existingMixin: mixin].

	cleanup.

	^results (* <List[InstanceMixin]> *)
)
private installAll = (
	| updateCount oldObjects newObjects index |
	updateCount:: updateMixinsAndClasses size + updateInstances size.
	oldObjects:: Array new: updateCount.
	newObjects:: Array new: updateCount.
	index: 1.
	updateInstances keysAndValuesDo:
		[:old :new |
		oldObjects at: index put: old.
		newObjects at: index put: new.
		index: index + 1].
	(* Put updated mixins and classes last, so A -> C follows B -> C (see class comment). *)
	updateMixinsAndClasses keysAndValuesDo:
		[:old :new |
		oldObjects at: index put: old.
		newObjects at: index put: (updateInstances at: old ifAbsent: [new]). (* Follow B to avoid B -> C, A -> B. *)
		index: index + 1].
	updateCount = 0 ifTrue: [^self].
	elementsOf: oldObjects forwardIdentityToElementsOf: newObjects.
)
private layoutHasChangedBetween: oldClass <Behavior> and: newClass <Behavior> ^<Boolean> = (
	| oldCls newCls oldMixin newMixin oldSlots newSlots |
	oldCls:: oldClass.
	newCls:: newClass.
	[nil = oldCls] whileFalse:
		[oldMixin:: mixinOf: oldCls.
		 newMixin:: mixinOf: newCls.
		 oldMixin = newMixin ifFalse:
			[oldSlots:: oldMixin _slots.
			 newSlots:: newMixin _slots.
			 oldSlots size = newSlots size ifFalse: [^true].
			 1 to: oldSlots size do:
				[:index | ((oldSlots at: index) name) = ((newSlots at: index) name) ifFalse: [^true]]].
		 oldCls:: superclassOf: oldCls.
		 newCls:: superclassOf: newCls].
	^false
)
private methodDictionaryFor: mixin <AbstractMixin> from: imixin <IntermediateMixin> ^<MethodDictionary> = (
	^(imixin assembleMethods collect:
		[:imethod <IntermediateMethod> |
		 imethod methodMixin: mixin.
		 imethod compiledMethod]) asArray
)
private noteUpdateOf: existingMixin <InstanceMixin | nil> to: newMixin <InstanceMixin> = (
	| applications <WeakArray> |
	nil = existingMixin ifTrue: [^self].

	updateMixinsAndClasses at: existingMixin put: newMixin.
	updateMixinsAndClasses at: existingMixin _classMixin put: newMixin _classMixin.

	applications:: existingMixin _applications.
	nil = applications ifFalse:
		[applications do: [:application <Class> | sortClass: application]].
)
private processClassDeclaration: classDecl <IntermediateClassDeclaration> ^<InstanceMixin> = (
	|
	mixin <Mixin>
	classMixin <ClassMixin>
	existingMixin <Mixin>
	nested
	|

	mixin:: InstanceMixin new.
	classMixin:: ClassMixin new.

	mixin _headerSource: classDecl headerSource.
	mixin _accessModifier: classDecl accessModifier.
	mixin _primaryFactorySelector: classDecl factoryName.
	classDecl factoryName isNil ifTrue: [panic].
	mixin _name: classDecl name.
	mixin _classMixin: classMixin.
	mixin _slots: (slotsFor: mixin from: classDecl instanceSide).
	mixin _methods: (methodDictionaryFor: mixin from: classDecl instanceSide).

	classMixin _instanceMixin: mixin.
	classMixin _methods: (methodDictionaryFor: classMixin from: classDecl classSide).

	existingMixin:: classDecl existingMixin.
	noteUpdateOf: existingMixin to: mixin.

	nil = existingMixin
		ifTrue:
		[newExistingMixins at: classDecl put: mixin]
		ifFalse:
		[(* If this is the top-most thing changed in this installation and not a top level class, the enclosingMixin won't otherwise be set and would incorrectly end up nil. *)
		mixin _enclosingMixin: existingMixin _enclosingMixin.
		mixin _classMixin _enclosingMixin: existingMixin _enclosingMixin].

	nested:: classDecl instanceSide nestedClasses collect:
		[:nestedClassDecl <IntermediateClassDeclaration> |
		| nestedMixin <InstanceMixin> |
		nestedMixin:: processClassDeclaration: nestedClassDecl.
		nestedMixin _enclosingMixin: mixin.
		nestedMixin _classMixin _enclosingMixin: mixin.
		nestedMixin].
	mixin _nestedMixins: nested asArray.
	^mixin
)
private processExistingClass: oldClass <Class> = (
	| oldSuperclass newSuperclass oldMixin newMixin oldEnclosingObject newClass |
	oldSuperclass:: superclassOf: oldClass.
	newSuperclass:: updateMixinsAndClasses at: oldSuperclass ifAbsent: [oldSuperclass].

	oldMixin:: mixinOf: oldClass.
	newMixin:: updateMixinsAndClasses at: oldMixin ifAbsent: [oldMixin].

	oldEnclosingObject:: enclosingObjectOf: oldClass.

	newClass:: newMixin
		apply: newSuperclass
		format: (nil = newSuperclass ifTrue: [0] ifFalse: [formatOf: newSuperclass])
		withName: newMixin _name
		enclosingObject: oldEnclosingObject.

	updateMixinsAndClasses at: oldClass putReplace: newClass.
	updateMixinsAndClasses at: (classOf: oldClass) put: (classOf: newClass).
)
private processExistingClasses = (
	| maxDepth ::= 0. |
	(* Process superclasses before subclasses. Create all new classes before remapping any instances. Remap instances in any order. *)
	existingClasses keysAndValuesDo:
		[:inheritanceDepth :classes |
		inheritanceDepth > maxDepth ifTrue:
			[maxDepth:: inheritanceDepth]].

	0 to: maxDepth do:
		[:inheritanceDepth |
		(existingClasses at: inheritanceDepth ifAbsent: [{}]) do:
			[:oldClass <Class> | processExistingClass: oldClass]].

	existingClasses keysAndValuesDo:
		[:inheritanceDepth :classes |
		classes do:
			[:oldClass <Class> | processInstancesOf: oldClass]].
)
private processInstancesOf: oldClass <Class> = (
	|
	newClass <Class> = updateMixinsAndClasses at: oldClass.
	oldSlotNames <Array[Symbol]>
	newSlotCount <Integer>
	remapIndices <Array[Integer]>
	|
	(layoutHasChangedBetween: oldClass and: newClass) ifFalse: [^self].

	(* Heuristic: choose the latter slot if a slot name is duplicated to favor overriding slots. *)
	oldSlotNames:: allInstVarNamesOf: oldClass.
	remapIndices:: (allInstVarNamesOf: newClass) collect:
		[:newSlotName | in: oldSlotNames lastIndexOf: newSlotName].
	newSlotCount:: remapIndices size.

	(* 'remapping with ' out.
	(((allInstVarNamesOf: oldClass) inject: '' into: [:a :b | a, ' ', b])
	, ' -> ',
	((allInstVarNamesOf: newClass) inject: '' into: [:a :b | a, ' ', b])) out.
	1 to: remapIndices size do: [:newIndex |
		(newIndex printString, '<-', (remapIndices at: newIndex) printString) out]. *)

	(allInstancesOf: oldClass) do:
		[:oldInstance |
		(* Avoid A -> D (see class comment). *)
		(updateMixinsAndClasses includesKey: oldInstance) ifFalse:
			[ | newInstance = allocate: newClass. |
			(* Copy state from oldInstance to newInstance. *)
			1 to: newSlotCount do: [:newIndex |
				| oldIndex value |
				oldIndex:: remapIndices at: newIndex.
				0 = oldIndex ifFalse: [
					value:: slotOf: oldInstance at: oldIndex.
					slotOf: newInstance at: newIndex put: value]].

			updateInstances at: oldInstance put: newInstance]].
)
private setup = (
	updateMixinsAndClasses:: IdentityMap new.
	updateInstances:: IdentityMap new.
	existingClasses:: IdentityMap new.
	newExistingMixins:: IdentityMap new. (* Regular Map okay here. *)
)
private slotsFor: mixin <InstanceMixin> from: imixin <IntermediateMixin> = (
	^(imixin assembleSlots collect:
		[:islot <IntermediateSlotDeclaration> |
		 islot compiledSlot]) asArray
)
private sortClass: app <Class> = (
	| classes depth subclasses |

	(* InstanceMixin>>applications and Class>>subclasses are weak. *)
	nil = app ifTrue: [^self].

	(* We might see classes more than once because they appear both as an application of a changed mixin, and as a subclasses of a changed class. *)
	(updateMixinsAndClasses at: app ifAbsentPutVal: nil) ifFalse: [^self].

	depth:: depthFor: app.
	classes:: existingClasses at: depth ifAbsentPut: [List new].
	classes add: app.

	subclasses:: subclassesOf: app.
	nil = subclasses ifFalse:
		[subclasses do: [:subclass | sortClass: subclass]].
)
) : (
)
public class ClassDeclarationBuilder fromIntermediate: ir = (|
private intermediate <IntermediateClassDeclaration> = ir.
public header <ClassHeaderBuilder> = ClassHeaderBuilder fromIntermediate: ir.
|) (
public accessModifier ^<Symbol> = (
	^intermediate accessModifier
)
public classSide ^<MixinBuilder> = (
	| ir builder |
	ir:: intermediate classSide.
	builder:: ir builder.
	nil = builder ifTrue:
		[builder:: MixinBuilder fromIntermediate: ir.
		 ir builder: builder].
	^builder
)
public enclosingClass ^<ClassDeclarationBuilder> = (
	| enclosingIR enclosingNested enclosingBuilder |
	enclosingIR:: intermediate enclosingClass.
	nil = enclosingIR ifFalse:
		[^enclosingIR declaration builder].
	nil = intermediate existingMixin ifTrue:
		[intermediate isTopLevel ifFalse: [panic]. ^nil].
	nil = intermediate existingMixin _enclosingMixin ifTrue:
		[intermediate isTopLevel ifFalse: [panic]. ^nil].

	enclosingIR:: buildIntermediateFor: intermediate existingMixin _enclosingMixin within: nil.

	(* Patch up link *)
	intermediate enclosingClass: enclosingIR instanceSide.

	(* Patch down link and accessor. *)
	enclosingNested:: enclosingIR instanceSide nestedClasses.
	1 to: enclosingNested size do: [:i |
		(enclosingNested at: i) name = intermediate name ifTrue:
			[intermediate accessor: (enclosingNested at: i) accessor.
			 enclosingNested at: i put: intermediate]].

	enclosingBuilder:: ClassDeclarationBuilder fromIntermediate: enclosingIR.
	enclosingIR builder: enclosingBuilder.
	enclosingBuilder instanceSide. (* Populate for incremental scope building. *)
	^enclosingBuilder
)
public install ^<ClassDeclarationMirror> = (
	| installer outermost |
	installer:: AtomicInstaller new.
	outermost:: intermediate.
	[nil = outermost enclosingClass] whileFalse:
		[outermost:: outermost enclosingClass declaration].
	installer install: {outermost}.
	nil = intermediate existingMixin ifTrue: [panic].
	^ClassDeclarationMirror reflecting: intermediate existingMixin
)
public instanceSide ^<MixinBuilder> = (
	| ir builder |
	ir:: intermediate instanceSide.
	builder:: ir builder.
	nil = builder ifTrue:
		[builder:: MixinBuilder fromIntermediate: ir.
		 ir builder: builder].
	^builder
)
public name = (
	^intermediate name
)
public source ^<String> = (
	| sb = StringBuilder new. |
	to: sb writeClassDeclaration: intermediate.
	^sb asString
)
private to: sb writeClassDeclaration: declIR = (
	sb add: declIR headerSource.
	sb writeln: ' ('.
	declIR instanceSide nestedClasses do:
		[:nestedIR | to: sb writeClassDeclaration: nestedIR].
	declIR instanceSide transientSlots do:
		[:transientSlot | sb writeln: transientSlot source].
	declIR instanceSide methods do:
		[:method | sb writeln: method source].
	sb writeln: ') : ('.
	declIR classSide methods do:
		[:method | sb writeln: method source].
	sb writeln: ')'.
)
) : (
public fromSource: source <String> ^<ClassDeclarationBuilder> = (
	| ir <IntermediateClassDeclaration> builder |
	ir:: compiler compileClassSource: source within: nil.
	builder:: self fromIntermediate: ir.
	ir builder: builder.
	^builder
)
)
private class ClassDeclarationMirror reflecting: mxn = (
	|
	mixin <InstanceMixin> = mxn.
	|
	reflectees at: self put: mxn.
) (
public = other ^<Boolean> = (
	(mixin = (reflectees at: other)) ifFalse: [^false].
	^other isKindOfClassDeclarationMirror
)
public accessModifier ^<Symbol> = (
	^mixin _accessModifier
)
public applyToObject ^<ClassMirror> = (
	nil = mixin _enclosingMixin ifFalse: [^notTopLevel].
	^ClassMirror reflecting: (mixin apply: Object withName: mixin _name enclosingObject: nil)
)
public asBuilder ^<ClassDeclarationBuilder> = (
	| ec ir builder |
	(* nil = mixin _enclosingMixin ifFalse: [unimplemented]. *)
	ec:: nil. (* Intermediates for enclosing class (if any) computed lazily. *)
	ir:: buildIntermediateFor: mixin within: ec.
	builder:: ClassDeclarationBuilder fromIntermediate: ir.
	ir builder: builder.
	^builder
)
public classSide ^<MixinMirror> = (
	^MixinMirror reflecting: mixin _classMixin
)
public definingMixin ^<MixinMirror> = (
	| em = mixin _enclosingMixin. |
	nil = em ifTrue: [^nil].
	^MixinMirror reflecting: em
)
public enclosingClass ^<ClassDeclarationMirror> = (
	| em = mixin _enclosingMixin. |
	nil = em ifTrue: [^nil].
	^ClassDeclarationMirror reflecting: em
)
public hash ^<Integer> = (
	^mixin hash bitXor: class hash
)
public header ^<ClassHeaderMirror> = (
	^ClassHeaderMirror reflecting: mixin in: self
)
public instanceSide ^<MixinMirror> = (
	^MixinMirror reflecting: mixin
)
public isKindOfClassDeclarationMirror ^<Boolean> = (
	^true
)
public name = (
	^mixin _name
)
public printString = (
	^'ClassDeclarationMirror:',name.
)
public source ^<String> = (
	| sb = StringBuilder new. |
	to: sb writeClassDeclaration: mixin.
	^sb asString
)
private to: sb writeClassDeclaration: instanceMixin = (
	sb add: instanceMixin _headerSource.
	sb writeln: ' ('.
	instanceMixin _nestedMixins do:
		[:nestedMixin | to: sb writeClassDeclaration: nestedMixin].
	instanceMixin _slots do:
		[:slot | slot isTransient ifTrue:
			[sb writeln: slot metadata]].
	instanceMixin _methods do:
		[:method | method isSynthetic ifFalse:
			[sb writeln: method source]].
	sb writeln: ') : ('.
	instanceMixin _classMixin _methods do:
		[:method | method isSynthetic ifFalse:
			[sb writeln: method source]].
	sb writeln: ')'.
)
) : (
)
private class ClassHeaderBuilder fromIntermediate: ir = (|
private intermediate <IntermediateClassDeclaration> = ir.
|) (
private checkForHeaderConflicts: newIntermediate <IntermediateClassDeclaration> = (
	newIntermediate instanceSide slots do:
		[:slot <IntermediateSlotDeclaration> |
		intermediate instanceSide
			checkNameConflictsForSlot: slot name
			mutable: slot isMutable].

	intermediate classSide checkNameConflictsForFactory: newIntermediate factoryName.
)
public declaration ^<ClassDeclarationBuilder> = (
	^intermediate builder
)
public metadata ^<Array[Metadata]> = (
	^metadataFrom: source
)
public name ^<String> = (
	^intermediate name
)
public name: newName <String> = (
	| parser newClassSource newIR |

	intermediate builder enclosingClass. (* For side effect. *)

	(* check for name conflict with sibling members *)
	intermediate isTopLevel ifFalse:
		[ | existing |
		existing:: intermediate enclosingClass nestedClasses
			detect: [:nested | nested name = newName]
			ifNone: [nil].
		(nil = existing or: [existing = intermediate builder])
			ifFalse: [^Exception signal: 'A sibling already exists with the name ', newName]].

	(* patch header source with the new name *)
	parser:: parsing Parser for: source.
	parser advanceToken parseClassHeaderForName.
	newClassSource::
		(source copyFrom: 1 to: parser tokenStart - 1) ,
		newName,
		(source copyFrom: parser tokenEnd + 1 to: source size).

	(* compile etc *)
	newIR:: compiler
		compileClassHeader: newClassSource
		within: intermediate enclosingClass.

	intermediate name: newIR name.
	intermediate headerSource: newIR headerSource.
	intermediate factoryName: newIR factoryName.
	intermediate accessor: newIR accessor.
	intermediate factory: newIR factory.
	intermediate initializers: newIR initializers.
	intermediate instanceSide slots: newIR instanceSide slots.
)
public primaryFactorySelector ^<String> = (
	^intermediate factoryName
)
public source ^<String> = (
	^intermediate headerSource
)
public source: newHeader <String> = (
	| prefix newIR |

	intermediate builder enclosingClass. (* For side effect. *)
	newIR:: compiler
		compileClassHeader: newHeader
		within: intermediate enclosingClass.

	checkForHeaderConflicts: newIR.
	intermediate name = newIR name ifFalse: [^Exception signal: 'Name changed'].

	intermediate headerSource: newIR headerSource.
	intermediate factoryName: newIR factoryName.
	intermediate accessor: newIR accessor.
	intermediate factory: newIR factory.
	intermediate initializers: newIR initializers.
	intermediate instanceSide slots: newIR instanceSide slots.
)
) : (
)
private class ClassHeaderMirror reflecting: mxn in: d = (
	|
	mixin <InstanceMixin> = mxn.
	public declaration <ClassDeclarationMirror> = d.
	|
	reflectees at: self put: mxn.
) (
public = other ^<Boolean> = (
	(mixin = (reflectees at: other)) ifFalse: [^false].
	^other isKindOfClassHeaderMirror
)
public hash ^<Integer> = (
	^mixin hash bitXor: class hash
)
private initializer ^<Method> = (
	| name = 'initializer`', mixin _primaryFactorySelector. |
	^mixin _methods detect: [:method | method selector = name]
)
public isKindOfClassHeaderMirror ^<Boolean> = (
	^true
)
public literals ^<Set[Object]> = (
	^(Printer for: initializer) literals
)
public metadata ^<Array[Metadata]> = (
	^metadataFrom: source
)
public name = (
	^mixin _name
)
private nestedClassAccessor ^<Method> = (
	|
	name = mixin _name.
	enclosing = mixin _enclosingMixin.
	|
	nil = enclosing ifTrue: [^nil].
	^enclosing  _methods detect: [:method | method selector = name]
)
public primaryFactorySelector ^<String> = (
	^mixin _primaryFactorySelector
)
public selectors ^<Set[String]> = (
	| accessor selectors |

	(* Nested classes accessor: keep only superclass send. *)
	accessor:: self nestedClassAccessor.
	nil = accessor
		ifTrue:
			[selectors:: Set new.
			 selectors add: #Object]
		ifFalse:
			[selectors:: (Printer for: accessor) selectors.
			 selectors
				removeAllSuchThat: [:selector | (selector indexOf: '`') > 0];
				remove: #=;
				remove: #apply:to:withEnclosingObject:].

	(* Initializer: Demangle super factory. Remove slot initializers. *)
	(Printer for: initializer) selectors do:
		[:selector |
		 (selector startsWith: 'initializer`') ifTrue:
			[selectors add: (selector copyFrom: 13 to: selector size) asSymbol].
		 (selector indexOf: '`') > 0 ifFalse:
			[selectors add: selector]].

	(* Factory: No user selectors. *)
	^selectors
)
public source ^<String> = (
	^mixin _headerSource
)
) : (
)
public class ClassMirror reflecting: behavior = (|
public reflectee <Behavior> = behavior.
|(isBehavior: behavior) ifFalse: [^Exception new signal].
reflectees at: self put: behavior) (
public = other ^<Boolean> = (
	(is: reflectee identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfClassMirror
)
public enclosingObject ^<ObjectMirror> = (
	^ObjectMirror reflecting: (enclosingObjectOf: reflectee)
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) hash bitXor: class hash
)
(* Answer a collection of all objects that have the reflectee as their class. Note this means instances of subclasses of the reflectee are not included. The order of objects is undefined. The result may include objects that are otherwise unreachable because garbage collection has not completed since the last reference was erased. *)
public instances ^<ObjectMirror[Array]> = (
	^ObjectMirror reflecting: (allInstancesOf: reflectee)
)
public isKindOfClassMirror ^<Boolean> = (
	^true
)
public isMeta ^<Boolean> = (
	^Metaclass = (classOf: reflectee)
)
public methods ^<Collection[MethodMirror]> = (
	| cls <Behavior> results <Collection[MethodMirror]> |
	cls:: reflectee.
	results:: List new.
	[nil = cls] whileFalse:
		[(methodsOf: cls) do:
			[:method <Method> |
			method isSynthetic ifFalse:
				[results add: (MethodMirror reflecting: method)]].
		cls:: superclassOf: cls].
	^MirrorGroup wrapping: results.
)
public mixin ^<MixinMirror> = (
	^MixinMirror reflecting: (mixinOf: reflectee)
)
public nestedClasses = (
	| cls <Behavior> results <Collection[ClassDeclarationMirror]> |
	cls:: reflectee.
	results:: List new.
	[nil = cls] whileFalse:
		[(mixinOf: cls) _nestedMixins do:
			[:nestedMixin <InstanceMixin> |
			results add: (ClassDeclarationMirror reflecting: nestedMixin)].
		cls:: superclassOf: cls].
	^MirrorGroup wrapping: results
)
public slots ^<Collection[SlotDeclarationMirror]> = (
	| cls <Behavior> classes result <Collection[SlotDeclarationMirror]> |
	cls:: reflectee.
	classes:: List new.
	result:: List new.
	[nil = cls] whileFalse:
		[classes add: cls.
		cls:: superclassOf: cls].
	classes size to: 1 by: -1 do:
		[:index |
		cls:: classes at: index.
		(mixinOf: cls) _slots do:
			[:slot |
			(slot name indexOf: '`') = 0 ifTrue:
				[(* Not synthetic. *)
				result add: (SlotDeclarationMirror
					name: slot name
					isMutable: slot isMutable
					accessModifier: slot accessModifier
					mixin: self mixin)]]].
	^MirrorGroup wrapping: result
)
(* Answer a collection of all classes that have the reflectee as their direct superclass. The order of classes is undefined. The result may include classes that are otherwise unreachable because garbage collection has not completed since the last reference was erased. *)
public subclasses ^<Collection[ClassMirror]> = (
	| result = List new. subclasses <WeakArray> |
	isMeta ifTrue: [^result]. (* Newspeak does not have inheritance on the class side. *)
	subclasses:: subclassesOf: reflectee.
	nil = subclasses ifTrue: [^result].
	subclasses do:
		[:subclass | nil = subclass ifFalse:
			[result add: (ClassMirror reflecting: subclass)]].
	^result
)
public superclass ^<ClassMirror> = (
	| s = superclassOf: reflectee. |
	nil = s ifTrue: [^nil].
	^ClassMirror reflecting: s
)
public transientSlots ^<Collection[TransientSlotDeclarationMirror]> = (
	| cls <Behavior> classes result <Collection[TransientSlotDeclarationMirror]> |
	cls:: reflectee.
	classes:: List new.
	result:: List new.
	[nil = cls] whileFalse:
		[classes add: cls.
		cls:: superclassOf: cls].
	classes size to: 1 by: -1 do:
		[:index |
		cls:: classes at: index.
		(mixinOf: cls) _slots do:
			[:slot |
			slot isTransient ifTrue:
				[result add: (TransientSlotDeclarationMirror
					descriptor: slot
					mixin: self mixin)]]].
	^MirrorGroup wrapping: result
)
) : (
)
public class ClosureMirror reflecting: c = (
	|
	public reflectee = c.
	|
	Closure = (classOf: c) ifFalse: [^(ArgumentError value: closure) signal].
	reflectees at: self put: reflectee.
) (
public = other ^<Boolean> = (
	(is: reflectee identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfClosureMirror
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) bitXor: class hash
)
public isKindOfClosureMirror ^<Boolean> = (
	^true
)
public method ^<MethodMirror> = (
	^MethodMirror reflecting: (definingActivationOf: reflectee) method
)
public receiver ^<ObjectMirror> = (
	^ObjectMirror reflecting: (definingActivationOf: reflectee) receiver
)
public slots ^<List[SlotMirror]> = (
	|
	simulator
	mapper
	result
	|
	simulator:: Simulator new.
	simulator activateClosure: reflectee arguments: (Array new: reflectee numArgs).
	mapper:: (computeDebugInfo: simulator activation method) mapperForContext: simulator activation.
	result:: List new.
	mapper localsDo:
		[:name :value |
		 result add: (SlotMirror
			name: name
			value: (ObjectMirror reflecting: value))].
	^result
)
public sourceRange ^<Interval> = (
	(* The create-closure bytecode is just before the closure's first bytecode. *)
	| method <Method> effectiveBCI <Integer> |
	method:: (definingActivationOf: reflectee) method.
	effectiveBCI:: Simulator bciBefore: (initialBCIOf: reflectee) in: method.
	^(computeDebugInfo: method) bciSourceMapping at: effectiveBCI
)
) : (
)
private class InstructionStream = (
) (
commonSend: offset = (
	0 = offset ifTrue: [^self ordinarySend: #+ numArgs: 1].
	1 = offset ifTrue: [^self ordinarySend: #- numArgs: 1].
	2 = offset ifTrue: [^self ordinarySend: #* numArgs: 1].
	3 = offset ifTrue: [^self ordinarySend: #// numArgs: 1].
	4 = offset ifTrue: [^self ordinarySend: #\\ numArgs: 1].
	5 = offset ifTrue: [^self ordinarySend: #<< numArgs: 1].
	6 = offset ifTrue: [^self ordinarySend: #>> numArgs: 1].
	7 = offset ifTrue: [^self ordinarySend: #& numArgs: 1].
	8 = offset ifTrue: [^self ordinarySend: #| numArgs: 1].
	9 = offset ifTrue: [^self ordinarySend: #< numArgs: 1].
	10 = offset ifTrue: [^self ordinarySend: #> numArgs: 1].
	11 = offset ifTrue: [^self ordinarySend: #<= numArgs: 1].
	12 = offset ifTrue: [^self ordinarySend: #>= numArgs: 1].
	13 = offset ifTrue: [^self ordinarySend: #= numArgs: 1].
	14 = offset ifTrue: [^self ordinarySend: #new numArgs: 0].
	15 = offset ifTrue: [^self ordinarySend: #new: numArgs: 1].
	16 = offset ifTrue: [^self ordinarySend: #at: numArgs: 1].
	17 = offset ifTrue: [^self ordinarySend: #at:put: numArgs: 2].
	18 = offset ifTrue: [^self ordinarySend: #size numArgs: 0].
	19 = offset ifTrue: [^self ordinarySend: #value numArgs: 0].
	20 = offset ifTrue: [^self ordinarySend: #value: numArgs: 1].
	21 = offset ifTrue: [^self ordinarySend: #value:value: numArgs: 2].
	22 = offset ifTrue: [^self ordinarySend: #name numArgs: 0].
	23 = offset ifTrue: [^self ordinarySend: #name: numArgs: 1].
	24 = offset ifTrue: [^self ordinarySend: #add: numArgs: 1].
	25 = offset ifTrue: [^self ordinarySend: #hash numArgs: 0].
	26 = offset ifTrue: [^self ordinarySend: #yourself numArgs: 0].
	27 = offset ifTrue: [^self ordinarySend: #, numArgs: 1].
	28 = offset ifTrue: [^self ordinarySend: #and: numArgs: 1].
	29 = offset ifTrue: [^self ordinarySend: #or: numArgs: 1].
	30 = offset ifTrue: [^self ordinarySend: #not numArgs: 0].
	31 = offset ifTrue: [^self ordinarySend: #basicNew numArgs: 0].
	^self unusedBytecode
)
interpretNext1Byte: byte = (
	byte <= 15 ifTrue: [^self jump: 0 - byte].
	byte <= 31 ifTrue: [^self jump: byte & 15].
	byte <= 47 ifTrue: [^self popJumpTrue: byte & 15].
	byte <= 63 ifTrue: [^self popJumpTrue: byte & 15].
	byte <= 79 ifTrue:
		[^self ordinarySend: (self literalAt: byte & 7) numArgs: byte >> 3 & 1].
	byte <= 95 ifTrue:
		[^self selfSend: (self literalAt: byte & 7) numArgs: byte >> 3 & 1].
	byte <= 111 ifTrue:
		[^self implicitReceiverSend: (self literalAt: byte & 7) numArgs: byte >> 3 & 1].
	byte <= 119 ifTrue: [^self pushParameter: byte & 7].
	byte <= 127 ifTrue: [^self pushLocal: byte & 7].
	byte <= 135 ifTrue: [^self popIntoLocal: byte & 7].
	byte <= 143 ifTrue: [^self storeIntoLocal: byte & 7].
	byte <= 151 ifTrue: [^self push: (self literalAt: byte & 7)].
	byte = 152 ifTrue: [^self push: nil].
	byte = 153 ifTrue: [^self push: false].
	byte = 154 ifTrue: [^self push: true].
	byte = 155 ifTrue: [^self pushReceiver].
	byte = 156 ifTrue: [^self pushMixin].
	byte = 158 ifTrue: [^self pop].
	byte = 159 ifTrue: [^self dup].
	byte = 160 ifTrue: [^self push: -1].
	byte = 161 ifTrue: [^self push: 0].
	byte = 162 ifTrue: [^self push: 1].
	byte = 163 ifTrue: [^self push: 2].

	byte = 166 ifTrue: [^self returnLocal: nil].
	byte = 167 ifTrue: [^self returnLocal: false].
	byte = 168 ifTrue: [^self returnLocal: true].
	byte = 169 ifTrue: [^self returnLocalReceiver].
	byte = 170 ifTrue: [^self returnLocalTop].
	byte = 171 ifTrue: [^self returnNonLocal: nil].
	byte = 172 ifTrue: [^self returnNonLocal: false].
	byte = 173 ifTrue: [^self returnNonLocal: true].
	byte = 174 ifTrue: [^self returnNonLocalReceiver].
	byte = 175 ifTrue: [^self returnNonLocalTop].
	byte <= 207 ifTrue: [^self commonSend: byte - 176].

	^self unusedBytecode
)
interpretNext2Byte: byte1 byte: byte2 = (
	byte1 = 222 ifTrue: [^self pushNewArray: byte2].
	byte1 = 223 ifTrue: [^self pushNewArrayWithElements: byte2].

	byte1 = 228 ifTrue: [^self pushParameter: byte2].
	byte1 = 229 ifTrue: [^self pushLocal: byte2].
	byte1 = 230 ifTrue: [^self popIntoLocal: byte2].
	byte1 = 231 ifTrue: [^self storeIntoLocal: byte2].

	byte1 = 233 ifTrue: [^self pushEnclosingObject: byte2].

	^self unusedBytecode
)
interpretNext3Byte: byte1 byte: byte2 byte: byte3 = (
	byte1 = 239 ifTrue:
		[^self eventualSend: (self literalAt: byte3 & 15 << 8 | byte2) numArgs: byte3 >> 4].
	byte1 = 240 ifTrue: [^self jump: 0 - (byte3 << 8 | byte2)].
	byte1 = 241 ifTrue: [^self jump: byte3 << 8 | byte2].
	byte1 = 242 ifTrue: [^self popJumpTrue: byte3 << 8 | byte2].
	byte1 = 243 ifTrue: [^self popJumpFalse: byte3 << 8 | byte2].
	byte1 = 245 ifTrue: [^self pushIndirectLocal: byte2 inVector: byte3].
	byte1 = 246 ifTrue: [^self popIntoIndirectLocal: byte2 inVector: byte3].
	byte1 = 247 ifTrue: [^self storeIntoIndirectLocal: byte2 inVector: byte3].
	byte1 = 248 ifTrue: [^self push: (self literalAt: byte3 << 8 | byte2)].
	byte1 = 249 ifTrue:
		[ | signedByte3 = byte3 >= 128 ifTrue: [byte3 - 256] ifFalse: [byte3]. |
		 ^self push: signedByte3 << 8 | byte2].
	byte1 = 250 ifTrue:
		[^self ordinarySend: (self literalAt: byte3 & 15 << 8 | byte2) numArgs: byte3 >> 4].
	byte1 = 251 ifTrue:
		[^self selfSend: (self literalAt: byte3 & 15 << 8 | byte2) numArgs: byte3 >> 4].
	byte1 = 252 ifTrue:
		[^self superSend: (self literalAt: byte3 & 15 << 8 | byte2) numArgs: byte3 >> 4].
	byte1 = 253 ifTrue:
		[^self implicitReceiverSend: (self literalAt: byte3 & 15 << 8 | byte2) numArgs: byte3 >> 4].

	^self unusedBytecode
)
interpretNext4Byte: byte1 byte: byte2 byte: byte3 byte: byte4 = (
	byte1 = 254 ifTrue:
		[^self
			outerSend: (self literalAt: (byte3 & 15) << 8 | byte2)
			numArgs: (byte3 >> 4)
			depth: byte4].
	byte1 = 255 ifTrue:
		[^self
			pushClosureNumCopied: byte2 >> 4
			numArgs: byte2 & 15
			blockSize: (byte4 << 8) | byte3].

	^self unusedBytecode
)
public interpretNextInstruction = (
	| bci bytecode byte byte2 byte3 byte4 |
	byte:: (bytecode:: self method bytecode) at: (bci:: self bci).
	byte <= 215 ifTrue:
		[self bci: bci + 1.
		 ^self interpretNext1Byte: byte].

	byte2:: bytecode at: bci + 1.
	byte <= 237 ifTrue:
		[self bci: bci + 2.
		 ^self interpretNext2Byte: byte byte: byte2].

	byte3:: bytecode at: bci + 2.
	byte <= 253 ifTrue:
		[self bci: bci + 3.
		 ^self interpretNext3Byte: byte byte: byte2 byte: byte3].

	byte4:: bytecode at: bci + 3.
	self bci: bci + 4.
	^self interpretNext4Byte: byte byte: byte2 byte: byte3 byte: byte4
)
literalAt: offset = (
	^self method literals at: 1 + offset
)
) : (
)
class Metadata tag: t payload: p = (
	|
	public tag <String> = t.
	public payload <String> = p.
	|
) (
) : (
)
private class MethodBuilder reflecting: ir in: builder = (|
private intermediate = ir.
public definingMixin = builder.
|) (
public accessModifier = (
	^intermediate accessModifier
)
public metadata ^<Array[Metadata]> = (
	^metadataFrom: source
)
public name = (
	^intermediate selector
)
public source ^<String> = (
	^intermediate source
)
) : (
)
private class MethodMirror reflecting: m = (|
	method <Method> = m.
|reflectees at: self put: m) (
public = other ^<Boolean> = (
	(is: method identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfMethodMirror
)
public accessModifier ^<Symbol> = (
	^method accessModifier
)
public definingMixin ^<MixinMirror> = (
	^MixinMirror reflecting: method mixin
)
public hash ^<Integer> = (
	^(identityHashOf: method) hash bitXor: class hash
)
public isKindOfMethodMirror ^<Boolean> = (
	^true
)
public literals ^<Set[Object]> = (
	^(Printer for: method) literals
)
public metadata ^<Array[Metadata]> = (
	^metadataFrom: source
)
public name = (
	^method selector
)
public selectors ^<Set[String]> = (
	^(Printer for: method) selectors
)
public source ^<String> = (
	(* :todo: Should this be async? *)
	^method source
)
) : (
)
private class MirrorGroup wrapping: collection = Collection (|
	protected mirrors <Collection[E extends Mirror]> = collection.
|) (
public do: action <[:E]> = (
	mirrors do: action
)
public findMirrorNamed: name <String> ^<E> = (
	(* :questionable: *)
	mirrors do: [:mirror | mirror name = name ifTrue: [^mirror]].
	^nil
)
public includesMirrorNamed: name <String> ^<Boolean> = (
	(* :questionable: *)
	mirrors do: [:mirror | mirror name = name ifTrue: [^true]].
	^false
)
protected newForCollectUsingAdd: capacity = (
	^List new: capacity
)
public size ^<Integer> = (
	^mirrors size
)
) : (
)
private class MixinBuilder fromIntermediate: ir = (|
private intermediate <IntermediateMixin> = ir.
private methodsX
private nestedClassesX
private slotsX
private transientSlotsX
|) (
public declaration ^<ClassDeclarationBuilder> = (
	^intermediate declaration builder
)
public isKindOfMixinMirror ^<Boolean> = (
	^true
)
public methods = (
	nil = methodsX ifTrue:
		[methodsX:: MutableMethodGroup fromIntermediate: intermediate].
	^methodsX
)
public nestedClasses = (
	nil = nestedClassesX ifTrue:
		[nestedClassesX:: MutableNestedClassGroup fromIntermediate: intermediate].
	^nestedClassesX
)
public slots = (
	nil = slotsX ifTrue:
		[slotsX:: MutableSlotGroup fromIntermediate: intermediate].
	^slotsX
)
public transientSlots = (
	nil = transientSlotsX ifTrue:
		[transientSlotsX:: MutableTransientSlotGroup fromIntermediate: intermediate].
	^transientSlotsX
)
) : (
)
private class MixinMirror reflecting: mxn = (
	|
	mixin <AbstractMixin> = mxn.
	|
	reflectees at: self put: mxn.
) (
public = other ^<Boolean> = (
	(mixin = (reflectees at: other)) ifFalse: [^false].
	^other isKindOfMixinMirror
)
(* Answer a collection of all classes that have the reflectee as their direct mixin. Note this does not include classes whose superclasses have the reflectee as their mixin. The order of classes is undefined. The result may include classes that are otherwise unreachable because garbage collection has not completed since the last reference was erased. *)
public applications ^<Collection[ClassMirror]> = (
	| result = List new. applications <WeakArray> |
	applications:: (isMeta ifTrue: [mixin _instanceMixin] ifFalse: [mixin]) _applications.
	nil = applications ifTrue: [^result].
	applications do:
		[:application | nil = application ifFalse:
			[result add:
				(ClassMirror reflecting:
					(isMeta ifTrue: [classOf: application] ifFalse: [application]))]].
	^result
)
public asBuilder ^<MixinBuilder> = (
	^isMeta
		ifTrue: [declaration asBuilder classSide]
		ifFalse: [declaration asBuilder instanceSide]
)
public declaration ^<ClassDeclarationMirror> = (
	^ClassDeclarationMirror reflecting:
		(mixin isMeta ifTrue: [mixin _instanceMixin] ifFalse: [mixin])
)
public enclosingMixin ^<MixinMirror> = (
	| em = mixin _enclosingMixin. |
	nil = em ifTrue: [^nil].
	^MixinMirror reflecting: em
)
public hash ^<Integer> = (
	^mixin hash bitXor: class hash
)
public isKindOfMixinMirror ^<Boolean> = (
	^true
)
public isMeta ^<Boolean> = (
	^mixin isMeta
)
public methods ^<Collection[MethodMirror]> = (
	| results = List new. |
	mixin _methods do:
		[:method |
		method isSynthetic ifFalse:
			[results add: (MethodMirror reflecting: method)]].
	^MirrorGroup wrapping: results
)
public name ^<String> = (
	^mixin _name
)
public nestedClasses ^<Collection[ClassDeclarationMirror]> = (
	| results <Collection[ClassDeclarationMirror]> |
	results:: List new.
	mixin _nestedMixins do:
		[:nestedMixin <InstanceMixin> |
		results add: (ClassDeclarationMirror reflecting: nestedMixin)].
	^MirrorGroup wrapping: results
)
public slots ^<Collection[SlotDeclarationMirror]> = (
	| results = List new. |
	mixin _slots do: [:slot |
		0 = (slot name indexOf: '`') ifTrue: (* not synthetic *)
			[results add: (SlotDeclarationMirror
				name: slot name
				isMutable: slot isMutable
				accessModifier: slot accessModifier
				mixin: self)]].
	^MirrorGroup wrapping: results
)
public transientSlots ^<Collection[TransientSlotDeclarationMirror]> = (
	| results = List new. |
	mixin _slots do: [:slot |
		slot isTransient ifTrue:
			[results add: (TransientSlotDeclarationMirror
				descriptor: slot
				mixin: self)]].
	^MirrorGroup wrapping: results
)
) : (
)
private class MutableMethodGroup fromIntermediate: ir = Collection (|
private intermediate <IntermediateMixin> = ir.
|) (
public addFromSource: source <String> = (
	|
	imethod <IntermediateMethod>
	|
	imethod:: compiler
		compileMethodSource: source
		within: intermediate builder.

	intermediate checkNameConflictsForMethod: imethod selector.

	intermediate methods removeAllSuchThat:
		[:ea | ea selector = imethod selector].
	intermediate methods add: imethod.

	^MethodBuilder reflecting: imethod in: intermediate builder
)
public do: action = (
	intermediate methods do:
		[:intermediateMethod |
		action value: (MethodBuilder
			reflecting: intermediateMethod
			in: intermediate builder)].
)
protected newForCollectUsingAdd: capacity = (
	^List new: capacity
)
public removeMirrorNamed: name <Symbol> = (
	intermediate methods removeAllSuchThat:
		[:imethod | imethod isSynthetic not and: [imethod selector = name]].
)
) : (
)
private class MutableNestedClassGroup fromIntermediate: ir = Collection (|
private intermediate <IntermediateMixin> = ir.
|) (
public addFromSource: source <String> ^<ClassDeclarationBuilder> = (
	| idecl <IntermediateClassDeclaration> builder |

	idecl:: compiler
		compileClassSource: source
		within: intermediate.

	intermediate checkNameConflictsForNestedClass: idecl name.

	intermediate nestedClasses removeAllSuchThat:
		[:nestedIR | nestedIR name = idecl name].
	intermediate nestedClasses add: idecl.

	builder:: ClassDeclarationBuilder fromIntermediate: idecl.
	idecl builder: builder.
	^builder
)
public do: action = (
	intermediate nestedClasses do:
		[:intermediateClassDeclaration |
		| builder |
		builder:: intermediateClassDeclaration builder.
		nil = builder ifTrue:
			[builder:: ClassDeclarationBuilder fromIntermediate: intermediateClassDeclaration.
			intermediateClassDeclaration builder: builder.

			(* :bogus: also find existingMixin *)
			].
		action value: builder].
)
protected newForCollectUsingAdd: capacity = (
	^List new: capacity
)
public removeMirrorNamed: name <Symbol> = (
	| nestedIntermediate |
	intermediate nestedClasses removeAllSuchThat:
		[:inested | inested name = name].
)
) : (
)
private class MutableSlotGroup fromIntermediate: ir = Collection (|
private intermediate <IntermediateMixin> = ir.
|) (
public do: action = (
	intermediate slots do:
		[:intermediateSlot |
		action value: (SlotDeclarationMirror
			name: intermediateSlot name
			isMutable: intermediateSlot isMutable
			accessModifier: intermediateSlot accessModifier
			mixin: intermediate builder)].
)
protected newForCollectUsingAdd: capacity = (
	^List new: capacity
)
) : (
)
private class MutableTransientSlotGroup fromIntermediate: ir = Collection (|
private intermediate <IntermediateMixin> = ir.
|) (
public addFromSource: source <String> = (
	|
	islot <IntermediateTransientSlotDeclaration>
	|
	islot:: compiler
		compileTransientSlotSource: source
		within: intermediate builder.

	intermediate checkNameConflictsForTransientSlot: islot name mutable: islot isMutable.

	intermediate transientSlots removeAllSuchThat:
		[:ea | ea name = islot name].
	intermediate transientSlots add: islot.

	^TransientSlotDeclarationBuilder reflecting: islot in: intermediate builder
)
public do: action = (
	intermediate transientSlots do:
		[:intermediateSlot |
		action value: (TransientSlotDeclarationBuilder
			reflecting: intermediateSlot
			in: intermediate builder)].
)
protected newForCollectUsingAdd: capacity = (
	^List new: capacity
)
public removeMirrorNamed: name <Symbol> = (
	intermediate transientSlots removeAllSuchThat:
		[:islot | islot name = name].
)
) : (
)
public class ObjectMirror reflecting: object = (
	|
	public reflectee = object.
	|
	reflectees at: self put: reflectee.
) (
public = other ^<Boolean> = (
	(is: reflectee identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfObjectMirror
)
private compileExpression: expression <String> with: rawScope <Map[Symbol, Object]> ^<Method> = (
	| receiverClass mixinMirror imethod result |
	receiverClass:: classOf: reflectee.
	mixinMirror:: (ClassMirror reflecting: receiverClass) mixin.
	imethod:: compiler
		compileExpressionSource: expression
		debugMapper: nil
		withScope: rawScope
		inMixin: mixinMirror.

	imethod methodMixin: (mixinOf: receiverClass).
	imethod source: expression.
	imethod debugInfo source: expression.
	^imethod compiledMethod metadata: imethod debugInfo
)
public evaluate: expression <String> ^<ThreadMirror> = (
	^(evaluateSuspended: expression) resume
)
public evaluate: expression <String> with: scope <Map[Symbol, ObjectMirror]> ^<ThreadMirror> = (
	^(evaluateSuspended: expression with: scope) resume
)
public evaluateSuspended: expression <String> ^<ThreadMirror> = (
	^evaluateSuspended: expression with: Map new
)
public evaluateSuspended: expression <String> with: scope <Map[Symbol, ObjectMirror]> ^<ThreadMirror> = (
	| rawScope expressionMethod thread simulator |
	rawScope:: Map new.
	scope keysAndValuesDo: [:key :value | rawScope at: key put: (reflectees at: value)].
	expressionMethod:: compileExpression: expression with: rawScope.

	simulator:: Simulator new.
	simulator activate: expressionMethod receiver: reflectee arguments: {nil. rawScope}.

	thread:: Thread new.
	thread state: #suspended.
	thread suspendedActivation: simulator activation.

	^ThreadMirror reflecting: thread
)
public getClass ^<ClassMirror> = (
	^ClassMirror reflecting: (classOf: reflectee)
)
public getSlot: name = (
	(* :deprecated: This form cannot access shadowed slots. Use #slots instead. *)
	| index raw |
	index:: indexOfSlotNamed: name in: (classOf: reflectee).
	raw:: slotOf: reflectee at: index.
	^ObjectMirror reflecting: raw
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) bitXor: class hash
)
(* Answer the number of bytes used by the representation of the reflectee. Note that 0 is a possible answer in implementations that use either pointer tagging or NaN boxing. *)
public heapSize ^<Integer> = (
	^heapSizeOf: reflectee
)
private indexOfSlotNamed: name in: startCls = (
	| cls slots |
	cls:: startCls.
	[nil = cls] whileFalse:
		[slots:: (mixinOf: cls) _slots.
		 1 to: slots size do:
			[:index | (slots at: index) name = name ifTrue:
				[^(formatOf: cls) - slots size + index]].
		 cls:: (superclassOf: cls)].
	^-1
)
public isKindOfObjectMirror ^<Boolean> = (
	^true
)
public referringObjects ^<ObjectMirror[Array]> = (
	^ObjectMirror reflecting: (allReferersOf: reflectee)
)
public setSlot: name to: value = (
	(* :deprecated: This form cannot access shadowed slots. Use #slots instead. *)
	| index raw |
	index:: indexOfSlotNamed: name in: (classOf: reflectee).
	slotOf: reflectee at: index put: value.
)
private slot: name value: value = (
	^SlotMirror name: name value: (ObjectMirror reflecting: value)
)
public slots ^<Collection[SlotMirror]> = (
	| cls format result cursor slots |
	cls:: classOf: reflectee.
	Array = cls ifTrue: [^slotsIndexed].
	WeakArray = cls ifTrue: [^slotsIndexed].
	ByteArray = cls ifTrue: [^slotsIndexed].
	String = cls ifTrue: [^slotsIndexed].
	Activation = cls ifTrue: [^slotsActivation].
	Closure = cls ifTrue: [^slotsClosure].
	format:: formatOf: cls.
	format < 0 ifTrue: [panic].
	result:: Array new: format.
	cursor:: format.
	[slots:: (mixinOf: cls) _slots.
	 slots size to: 1 by: -1 do:
		[:i |
		 result at: cursor put:
			(slot: ((slots at: i) name) value: (slotOf: reflectee at: cursor)).
		 cursor:: cursor - 1].
	 cls:: superclassOf: cls.
	 cls = nil] whileFalse.
	^result
)
private slotsActivation ^<Collection[SlotMirror]> = (
	|
	size = reflectee size.
	result = Array new: 6 + size.
	|
	result at: 1 put: (slot: #sender value: reflectee sender).
	result at: 2 put: (slot: #bci value: reflectee bci).
	result at: 3 put: (slot: #method value: reflectee method).
	result at: 4 put: (slot: #closure value: reflectee closure).
	result at: 5 put: (slot: #receiver value: reflectee receiver).
	result at: 6 put: (slot: #size value: size).
	1 to: size do:
		[:index | result at: 6 + index put:
			(slot: index value: (reflectee tempAt: index))].
	^result
)
private slotsClosure ^<Collection[SlotMirror]> = (
	|
	size = numCopiedOf: reflectee.
	result = Array new: 4 + size.
	|
	result at: 1 put: (slot: #numCopied value: size).
	result at: 2 put: (slot: #definingActivation value: (definingActivationOf: reflectee)).
	result at: 3 put: (slot: #initialBCI value: (initialBCIOf: reflectee)).
	result at: 4 put: (slot: #numArgs value: reflectee numArgs).
	1 to: size do:
		[:index | result at: 4 + index put:
			(slot: index value: (copiedOf: reflectee at: index))].
	^result
)
private slotsIndexed ^<Collection[SlotMirror]> = (
	|
	size = reflectee size.
	result = Array new: 1 + size.
	|
	result at: 1 put: (slot: #size value: size).
	1 to: size do:
		[:index | result at: 1 + index put:
			(slot: index value: (reflectee at: index))].
	^result
)
) : (
)
class Printer for: method_ = InstructionStream (
	|
	bci ::= 1.
	method = method_.
	public selectors = Set new.
	public literals = Set new.
	|
	scan.
) (
dup = ()
eventualSend: selector numArgs: numArgs = (
	selectors add: selector.
)
implicitReceiverSend: selector numArgs: numArgs = (
	selectors add: selector.
)
jump: delta = ()
ordinarySend: selector numArgs: numArgs = (
	selectors add: selector.
)
outerSend: selector numArgs: numArgs depth: depth = (
	selectors add: selector.
)
pop = ()
popIntoIndirectLocal: offset inVector: vectorOffset = ()
popIntoLocal: offset = ()
popJumpFalse: delta = ()
popJumpTrue: delta = ()
push: value = (
	literals add: value.
)
pushClosureNumCopied: numCopied numArgs: numArgs blockSize: blockSize = ()
pushEnclosingObject: depth = ()
pushIndirectLocal: offset inVector: vectorOffset = ()
pushLocal: offset = ()
pushMixin = ()
pushNewArray: size = ()
pushNewArrayWithElements: size = ()
pushParameter: offset = ()
pushReceiver = ()
returnLocal: value = (
	literals add: value.
)
returnLocalReceiver = ()
returnLocalTop = ()
returnNonLocal: value = (
	literals add: value.
)
returnNonLocalReceiver = ()
returnNonLocalTop = ()
scan = (
	| end |
	nil = method bytecode ifTrue: [^self].
	end:: method bytecode size.
	[bci <= end] whileTrue: [self interpretNextInstruction].
)
selfSend: selector numArgs: numArgs = (
	selectors add: selector.
)
storeIntoIndirectLocal: offset inVector: vectorOffset = ()
storeIntoLocal: offset = ()
superSend: selector numArgs: numArgs = (
	selectors add: selector.
)
) : (
)
private class Simulator = InstructionStream (|
public activation
|) (
aboutToReturn: result through: firstUnwindActivation = (
	| method |
	method:: behavior: Activation methodAt: #aboutToReturn:through:.
	activate: method receiver: activation arguments: {result. firstUnwindActivation}.
)
public activate: newMethod receiver: newReceiver arguments: arguments = (
	| newActivation |

	(tryPrimitive: newMethod primitive receiver: newReceiver arguments: arguments)
		ifTrue: [^self].

	newActivation:: Activation new.
	newActivation sender: activation.
	newActivation bci: 1.
	newActivation method: newMethod.
	newActivation closure: nil.
	newActivation receiver: newReceiver.

	newActivation size: newMethod numTemps.
	1 to: arguments size do:
		[:index | newActivation tempAt: index put: (arguments at: index)].

	(* ('sim: ', newActivation printString) out. *)

	activation:: newActivation.
)
public activateClosure: closure arguments: arguments = (
	| newActivation |
	newActivation:: Activation new.
	newActivation sender: activation.
	newActivation bci: (initialBCIOf: closure).
	newActivation method: (definingActivationOf: closure) method.
	newActivation closure: closure.
	newActivation receiver: (definingActivationOf: closure) receiver.
	arguments size = closure numArgs ifFalse: [panic].
	arguments do:
		[:argument | newActivation push: argument].
	1 to: (numCopiedOf: closure) do:
		[:index | newActivation push: (copiedOf: closure at: index)].

	(* ('sim: ', newActivation printString) out. *)
	activation:: newActivation.
)
bci = (
	^activation bci
)
bci: value = (
	activation bci: value
)
behavior: behavior hasSelector: selector = (
	(methodsOf: behavior) do: [:method | method selector = selector ifTrue: [^true]].
	^false
)
public behavior: behavior methodAt: selector = (
	(methodsOf: behavior) do: [:method | method selector = selector ifTrue: [^method]].
	^nil
)
cannotReturn: result = (
	| method |
	method:: behavior: Activation methodAt: #cannotReturn:.
	activate: method receiver: activation arguments: {result}.
)
private doPrimitive: index <Integer> receiver: receiver <Object> arguments: arguments <Array> = (
	(* :pragma: primitive: 181 *)
	'doPrimitive failed' out.
	index out.
	receiver out.
	arguments size out.
	panic.
)
dup = (
	activation push: activation top.
)
eventualSend: selector numArgs: numArgs = (
	| arguments receiver loop method |
	pushNewArrayWithElements: numArgs.
	arguments:: activation pop.
	receiver:: activation pop.
	loop:: internalKernel messageLoop.
	method:: behavior: (classOf: loop) methodAt: #eventualSendTo:selector:arguments:.
	activate: method receiver: loop arguments: {receiver. selector. arguments}.
)
public findApplicationOf: mixin startingAt: startingBehavior = (
	| behavior ::= startingBehavior. |
	[nil = behavior] whileFalse:
		[mixin = (mixinOf: behavior) ifTrue: [^behavior].
		 behavior:: (superclassOf: behavior)].
	panic.
)
implicitReceiverSend: selector numArgs: numArgs = (
	| arguments candidateReceiver candidateMixin candidateMixinApplication |
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	candidateReceiver:: activation receiver.
	candidateMixin:: activation method mixin.
	[candidateMixinApplication::
		findApplicationOf: candidateMixin
		startingAt: (classOf: candidateReceiver).
	(behavior: candidateMixinApplication hasSelector: selector) ifTrue:
		[^sendLexical: selector to: candidateReceiver arguments: arguments wrt: candidateMixin].
	candidateMixin:: candidateMixin _enclosingMixin.
	nil = candidateMixin ifTrue:
		[^sendProtected: selector to: activation receiver arguments: arguments startingAt: (classOf: activation receiver)].
	candidateReceiver:: enclosingObjectOf: candidateMixinApplication.
	] repeat.
)
jump: delta = (
	activation bci: activation bci + delta.
)
localToTemp: offset = (
	^(nil = activation closure
		ifTrue: [activation method numArgs]
		ifFalse: [activation closure numArgs]) + offset + 1
)
method = (
	^activation method
)
private newClosureIn: definingActivation initialBCI: initialBCI numArgs: numArgs numCopied: numCopied = (
	(* :pragma: primitive: 145 *)
	panic.
)
nonBooleanReceiver: nonBoolean = (
	| method |
	method:: behavior: Activation methodAt: #nonBooleanReceiver:.
	activate: method receiver: activation arguments: {nonBoolean}.
)
ordinarySend: selector numArgs: numArgs = (
	| arguments messageReceiver receiverClass lookupClass targetMethod |
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	messageReceiver:: activation pop.
	lookupClass:: receiverClass:: classOf: messageReceiver.
	[nil = lookupClass] whileFalse:
		[targetMethod:: behavior: lookupClass methodAt: selector.
		 nil = targetMethod ifFalse:
			[targetMethod isPublic ifTrue:
				[^activate: targetMethod receiver: messageReceiver arguments: arguments].
			 targetMethod isProtected ifTrue:
				[^sendDnu: selector to: messageReceiver arguments: arguments startingAt: receiverClass]].
		 lookupClass:: superclassOf: lookupClass].
	^sendDnu: selector to: messageReceiver arguments: arguments startingAt: receiverClass
)
outerSend: selector numArgs: numArgs depth: depth = (
	| arguments receiver targetMixin count mixinApplication |
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	receiver:: activation receiver.
	targetMixin:: activation method mixin.
	count:: 0.
	[count < depth] whileTrue:
		[count:: count + 1.
		mixinApplication:: findApplicationOf: targetMixin startingAt: (classOf: receiver).
		receiver:: enclosingObjectOf: mixinApplication.
		targetMixin:: targetMixin _enclosingMixin].
	^sendLexical: selector to: receiver arguments: arguments wrt: targetMixin.
)
pop = (
	activation pop
)
popIntoIndirectLocal: offset inVector: vectorOffset = (
	| vector = activation tempAt: (localToTemp: vectorOffset). |
	vector at: 1 + offset put: activation pop.
)
popIntoLocal: offset = (
	activation tempAt: (localToTemp: offset) put: activation pop.
)
popIntoTemporary: offset = (
	activation tempAt: 1 + offset put: activation pop.
)
popJumpFalse: delta = (
	| top = activation pop. |
	true = top ifTrue: [^self].
	false = top ifTrue:
		[activation bci: activation bci + delta.
		^self].
	^nonBooleanReceiver: top
)
popJumpTrue: delta = (
	| top = activation pop. |
	true = top ifTrue:
		[activation bci: activation bci + delta.
		^self].
	false = top ifTrue: [^self].
	^nonBooleanReceiver: top
)
push: value = (
	activation push: value
)
pushClosureNumCopied: numCopied numArgs: numArgs blockSize: blockSize ^<Activation> = (
	| newClosure |
	newClosure::
		newClosureIn: activation
		initialBCI: activation bci
		numArgs: numArgs
		numCopied: numCopied.

	numCopied to: 1 by: -1 do:
		[:index | copiedOf: newClosure at: index put: activation pop].

	activation push: newClosure.
	activation bci: activation bci + blockSize.
)
pushEnclosingObject: depth = (
	| enclosingObject targetMixin count mixinApplication |
	enclosingObject:: activation receiver.
	targetMixin:: activation method mixin.
	count:: 0.
	[count < depth] whileTrue:
		[count:: count + 1.
		mixinApplication:: findApplicationOf: targetMixin startingAt: (classOf: enclosingObject).
		enclosingObject:: enclosingObjectOf: mixinApplication.
		targetMixin:: targetMixin _enclosingMixin].
	activation push: enclosingObject.
)
pushIndirectLocal: offset inVector: vectorOffset = (
	| vector = activation tempAt: (localToTemp: vectorOffset). |
	activation push: (vector at: 1 + offset).
)
pushLocal: offset = (
	activation push: (activation tempAt: (localToTemp: offset)).
)
pushMixin = (
	activation push: activation method mixin.
)
pushNewArray: size = (
	activation push: (Array new: size).
)
pushNewArrayWithElements: size = (
	| newArray = Array new: size. |
	size to: 1 by: -1 do: [:index | newArray at: index put: activation pop].
	activation push: newArray.
)
pushParameter: offset = (
	| numArgs |
	numArgs:: nil = activation closure
		ifTrue: [activation method numArgs]
		ifFalse: [activation closure numArgs].
	activation push: (activation tempAt: numArgs - offset + 1).
)
pushReceiver = (
	activation push: activation receiver.
)
pushTemporary: offset = (
	activation push: (activation tempAt: 1 + offset).
)
returnLocal: result = (
	| sender = activation sender. |
	nil = sender ifTrue: [^cannotReturn: result].
	sender isDead ifTrue: [^cannotReturn: result].
	activation terminate.
	sender push: result.
	activation: sender.
)
returnLocalReceiver = ( ^returnLocal: activation receiver )
returnLocalTop = ( ^returnLocal: activation pop )
returnNonLocal: result = (
	| closure home unwind sender zap next |
	closure:: activation closure.
	home:: definingActivationOf: closure.
	closure:: home closure.
	[nil = closure] whileFalse:
		[home:: definingActivationOf: closure.
		 closure:: home closure].

	unwind:: activation sender.
	[unwind = home] whileFalse:
		[nil = unwind ifTrue:
			[^cannotReturn: result].
		unwind method primitive = 162 ifTrue:
			[^aboutToReturn: result through: unwind].
		unwind method primitive = 163 ifTrue:
			[^cannotReturn: result].
		unwind:: unwind sender].

	sender:: home sender.
	(nil = sender or: [sender isDead]) ifTrue:
		[^cannotReturn: result].

	(* Mark activations on the dynamic chain up to the return target as dead. Note this follows the behavior of Squeak instead of the blue book, which only zaps A. *)
	zap:: activation.
	[next:: zap sender.
	 zap terminate.
	 zap:: next.
	 zap = sender] whileFalse.

	sender push: result.
	activation: sender.
	(* ('sim: ', activation printString) out. *)
)
returnNonLocalReceiver = ( ^returnNonLocal: activation receiver )
returnNonLocalTop = ( ^returnNonLocal: activation pop )
selfSend: selector numArgs: numArgs = (
	| arguments |
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	^sendLexical: selector to: activation receiver arguments: arguments wrt: activation method mixin
)
sendDnu: selector to: messageReceiver arguments: arguments startingAt: mixinApp = (
	| lookupClass message dnuMethod |
	lookupClass:: mixinApp.
	message:: Message selector: selector arguments: arguments.
	[nil = lookupClass] whileFalse:
		[dnuMethod:: behavior: lookupClass methodAt: #doesNotUnderstand:.
		 nil = dnuMethod ifFalse:
			[^activate: dnuMethod receiver: messageReceiver arguments: {message} ].
		 lookupClass:: superclassOf: lookupClass].
	error: 'Recursive doesNotUnderstand:'
)
sendLexical: selector to: messageReceiver arguments: arguments wrt: mixin = (
	| receiverClass mixinApplication targetMethod |
	receiverClass:: classOf: messageReceiver.
	mixinApplication:: findApplicationOf: mixin startingAt: receiverClass.
	targetMethod:: behavior: mixinApplication methodAt: selector.
	nil = targetMethod ifFalse:
		[targetMethod isPrivate ifTrue:
			[^activate: targetMethod receiver: messageReceiver arguments: arguments]].
	^sendProtected: selector to: messageReceiver arguments: arguments startingAt: receiverClass
)
sendProtected: selector to: messageReceiver arguments: arguments startingAt: mixinApp = (
	| lookupClass targetMethod |
	lookupClass:: mixinApp.
	[nil = lookupClass] whileFalse:
		[targetMethod:: behavior: lookupClass methodAt: selector.
		 nil = targetMethod ifFalse:
			[targetMethod isPrivate ifFalse:
				[^activate: targetMethod receiver: messageReceiver arguments: arguments]].
		lookupClass:: superclassOf: lookupClass].
	^sendDnu: selector to: messageReceiver arguments: arguments startingAt: mixinApp
)
storeIntoIndirectLocal: offset inVector: vectorOffset = (
	| vector = activation tempAt: (localToTemp: vectorOffset). |
	vector at: 1 + offset put: activation top.
)
storeIntoLocal: offset = (
	activation tempAt: (localToTemp: offset) put: activation top.
)
storeIntoTemporary: offset = (
	activation tempAt: 1 + offset put: activation top.
)
superSend: selector numArgs: numArgs = (
	| arguments messageReceiver methodMixinApplication |
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	messageReceiver:: activation receiver.
	methodMixinApplication:: findApplicationOf: activation method mixin startingAt: (classOf: messageReceiver).
	^sendProtected: selector to: messageReceiver arguments: arguments startingAt: (superclassOf: methodMixinApplication)
)
tryPrimitive: primitive receiver: newReceiver arguments: arguments = (
	| result |

	0 = primitive ifTrue: [^false].

	(* Simulation guard *)
	(* x = primitive ifTrue: ['simulation guard' out. panic]. *)

	(* Current activation *)
	164 = primitive ifTrue: [activation push: activation. ^true].

	(* Closure activation *)
	156 = primitive ifTrue:
		[newReceiver numArgs = 0 ifFalse: [^false].
		 activateClosure: newReceiver arguments: arguments.
		 ^true].
	157 = primitive ifTrue:
		[newReceiver numArgs = 1 ifFalse: [^false].
		 activateClosure: newReceiver arguments: arguments.
		 ^true].
	158 = primitive ifTrue:
		[newReceiver numArgs = 2 ifFalse: [^false].
		 activateClosure: newReceiver arguments: arguments.
		 ^true].
	159 = primitive ifTrue:
		[newReceiver numArgs = 3 ifFalse: [^false].
		 activateClosure: newReceiver arguments: arguments.
		 ^true].
	160 = primitive ifTrue:
		[ | closureArgs = arguments at: 1. |
		 Array = (classOf: closureArgs) ifFalse: [^false].
		 closureArgs size = newReceiver numArgs ifFalse: [^false].
		 activateClosure: newReceiver arguments: closureArgs.
		 ^true].

	(* Jump *)
	165 = primitive ifTrue: [activation:: arguments at: 1. ^true].

	(* Perform *)
	134 = primitive ifTrue:
		[ | object selector performArguments |
		object:: arguments at: 1.
		selector:: arguments at: 2.
		performArguments:: arguments at: 3.
		(* :todo: Where should we fail on arity mismatch? *)
		(String = (classOf: selector)) ifFalse: [^false].
		(Array = (classOf: performArguments)) ifFalse: [^false].
		activation push: object.
		performArguments do: [:arg | activation push: arg].
		ordinarySend: selector numArgs: performArguments size.
		^true].

	result:: doPrimitive: primitive receiver: newReceiver arguments: arguments.
	arguments = result ifFalse:
		[activation push: result.
		 ^true].
	^false
)
) : (
public bciBefore: afterBci in: method = (
	| beforeBci bci bytecode = method bytecode. |
	beforeBci:: bci:: 1.
	[bci < afterBci] whileTrue:
		[beforeBci:: bci.
		 bci:: bci + (sizeOf: (bytecode at: bci))].
	^beforeBci
)
sizeOf: bytecode = (
	bytecode <= 215 ifTrue: [^1].
	bytecode <= 237 ifTrue: [^2].
	bytecode <= 253 ifTrue: [^3].
	^4
)
)
private class SlotDeclarationMirror name: n isMutable: m accessModifier: a mixin: mxn = (|
public name = n.
public isMutable = m.
public accessModifier = a.
public definingMixin = mxn.
|) (
public isKindOfSlotDeclarationMirror ^<Boolean> = (
	^true
)
) : (
)
private class SlotMirror name: n value: v = (
|
public name <Symbol> = n.
public value <ObjectMirror> = v.
|
) (
) : (
)
private class SyntheticMethodMirror reflecting: m name: n source: s = MethodMirror reflecting: m (|
	public name <Symbol> = n.
	public source <String> = s.
|) (
) : (
)
private class Thread = (
	|
	public state ::= #initial.
	public result
	public suspendedActivation
	|
) (
private createSimulationRoot = (
	| root = Activation new. |
	(* bottom sender: nil *) (* Note that the current activation is not attached as the sender of the simulated activation. This prevents a non-local return from crossing the simulation boundry. *)
	root method: simulatorRootMethod. (* Marks the activation as a simulation root. Used to route unhandled exceptions. *)
	root bci: 0. (* Marks the activation as not dead so the final return can succeed. *)
	(* bottom closure: nil *)
	(* bottom receiver: nil *)
	root push: self. (* Known to exception signaling machinery. *)
	^root
)
private findBottom: top <Activation> = (
	| bottom ::= top. |
	[isBottom: bottom] whileFalse: [bottom:: bottom sender].
	^bottom
)
private has: top reachedOrSkipped: goal = (
	| a ::= top. |
	a = goal ifTrue: [^true]. (* reached *)
	[nil = a]
		whileFalse:
			[a = goal ifTrue: [^false]. (* not reached, not skipped *)
			 a:: a sender].
	^true (* skipped *)
)
private has: top reachedOrSkippedHome: goal = (
	| a ::= top. |
	a home = goal ifTrue: [^true]. (* reached *)
	[nil = a]
		whileFalse:
			[a home = goal ifTrue: [^false]. (* not reached, not skipped *)
			 a:: a sender].
	^true (* skipped *)
)
private hasSender: activation = (
	| s ::= suspendedActivation. |
	[nil = s] whileFalse: [s = activation ifTrue: [^true]. s:: s sender].
	^false
)
private isBottom: activation <Activation> ^<Boolean> = (
	nil = activation sender ifTrue: [^true].
	^163 = activation sender method primitive
)
private jumpTo: activation = (
	(* :pragma: primitive: 165 *)
	panic.
)
private lookupNewMethod: activation = (
	| simulator oldMethod methodClass newMethod |
	simulator:: Simulator new.
	oldMethod:: activation method.
	methodClass:: simulator findApplicationOf: oldMethod mixin startingAt: (classOf: activation receiver).
	newMethod:: simulator behavior: methodClass methodAt: oldMethod selector.
	nil = newMethod ifTrue: [^oldMethod].
	^newMethod
)
private prepareToResumeWithRoot: simulationRoot <Activation> = (
	| top bottom <Activation> |
	top:: suspendedActivation.
	(findBottom: top) sender: simulationRoot.
	state = #broken ifTrue: [top push: result]. (* Result of #signal *)
	state: #running.
	suspendedActivation: nil.
	^top
)
public restart: activation withLookup: doLookup = (
	| closure newMethod |
	(hasSender: activation) ifFalse:
		[^Exception signal: 'Activation is not in thread'].
	doLookup ifTrue:
		[nil = activation closure ifFalse:
			[^Exception signal: 'Cannot lookup closure activations']].
	unwindTo: activation.
	newMethod:: doLookup
		ifTrue: [lookupNewMethod: activation]
		ifFalse: [activation method].
	restart: activation withMethod: newMethod.
	state: #suspended.
)
private restart: activation withMethod: newMethod = (
	| closure |
	closure:: activation closure.
	activation method: newMethod.
	nil = closure
		ifTrue:
			[activation bci: 1.
			 activation size: newMethod numArgs.
			 activation size: newMethod numTemps]
		ifFalse:
			[activation bci: (initialBCIOf: closure).
			 activation size: closure numArgs.
			 1 to: (numCopiedOf: closure) do:
				[:index | activation push: (copiedOf: closure at: index)]].
)
public resume = (
	(* The state check is in a separate method because we don't want a method marked as a simulation root to be on the stack when the exception is signaled. *)
	nil = suspendedActivation ifTrue:
		[^Exception signal: 'Nothing to resume'].
	^resumeImpl
)
private resumeImpl = (
	(* :pragma: primitive: 163 *)
	| threadAtTemp1 jumpResult |
	threadAtTemp1:: self. (* Known to exception signaling machinery. *)

	jumpResult:: jumpTo: (prepareToResumeWithRoot: currentActivation).

	state = #broken ifTrue:
		[result: jumpResult.
		 ^self].

	state: #fulfilled.
	result: jumpResult.
)
public resumeSlowly = (
	stepUntil: [:top | false].
)
public return: returnValue from: activation = (
	(hasSender: activation) ifFalse:
		[^Exception signal: 'Activation is not in thread'].

	(isBottom: activation) ifTrue:
		[unwindTo: activation.
		 suspendedActivation terminate.
		 suspendedActivation:: nil.
		 result:: returnValue.
		 state:: #fulfilled.
		 ^self].

	unwindTo: activation sender.
	suspendedActivation push: returnValue.
	state: #suspended.
)
private simulatorRoot = (
	(* :pragma: primitive: 163 *)
	panic.
)
private simulatorRootMethod = (
	| methods = methodsOf: self class. |
	1 to: methods size do:
		[:index | | method = methods at: index. |
		method selector = #simulatorRoot ifTrue: [^method]].
	panic.
)
public stepInto = (
	nil = suspendedActivation ifTrue:
		[^Exception signal: 'Nothing to resume'].
	stepUntil: [:top | true].
)
public stepInto: activation = (
	(hasSender: activation) ifFalse:
		[^Exception signal: 'Activation is not in thread'].
	stepUntil: [:top | true].
)
public stepOut: activation = (
	| goal = activation sender. |
	(hasSender: activation) ifFalse:
		[^Exception signal: 'Activation is not in thread'].
	(isBottom: activation) ifTrue:
		[^resume].
	stepUntil: [:top | has: top reachedOrSkipped: goal].
)
public stepOver: activation = (
	(hasSender: activation) ifFalse:
		[^Exception signal: 'Activation is not in thread'].
	stepUntil: [:top | has: top reachedOrSkipped: activation].
)
public stepThrough: activation = (
	| goal = activation home. |
	(hasSender: activation) ifFalse:
		[^Exception signal: 'Activation is not in thread'].
	stepUntil: [:top | has: top reachedOrSkippedHome: goal].
)
private stepUntil: predicate <[:Activation | Boolean]> = (
	| root simulator = Simulator new. |
	root:: createSimulationRoot.
	simulator activation: (prepareToResumeWithRoot: root).

	root = simulator activation ifTrue: [panic].

	[simulator interpretNextInstruction.
	 root = simulator activation or: [predicate value: simulator activation]] whileFalse.

	root = simulator activation ifFalse:
		[state: #suspended.
		 suspendedActivation: simulator activation.
		 ^self].

	state = #broken ifTrue:
		[result: simulator activation pop.
		 ^self].

	state: #fulfilled.
	result: simulator activation pop.
)
public terminate = (
	nil = suspendedActivation ifTrue:
		[^Exception signal: 'Nothing to terminate'].
	unwindTo: (findBottom: suspendedActivation) sender.
	suspendedActivation: nil.
	state: #terminated.
	result: nil.
)
private unwindTo: activation = (
	| unwind sender |
	unwind:: suspendedActivation.
	[unwind = activation] whileFalse:
		[unwind isUnwindContext ifTrue:
			[^Exception signal: 'Unwind-protect unimplemented'].
		 unwind:: unwind sender].

	unwind:: suspendedActivation.
	[unwind = activation] whileFalse:
		[sender:: unwind sender.
		 unwind terminate.
		 unwind:: sender].
	suspendedActivation:: activation.
)
) : (
)
private class ThreadMirror reflecting: t = (
	| protected thread = t. |
) (
public isBroken ^<Boolean> = (
	^thread state = #broken
)
public isFulfilled ^<Boolean> = (
	^thread state = #fulfilled
)
public isKindOfThreadMirror ^<Boolean> = (
	^true
)
public isRunning ^<Boolean> = (
	^thread state = #running
)
public isSuspended ^<Boolean> = (
	^thread state = #suspended
)
public isTerminated ^<Boolean> = (
	^thread state = #terminated
)
public result ^<ObjectMirror | nil> = (
	thread state = #fulfilled ifTrue: [^ObjectMirror reflecting: thread result].
	thread state = #broken ifTrue: [^ObjectMirror reflecting: thread result].
	^nil
)
public resume ^<ThreadMirror> = (
	thread resume.
)
public resumeSlowly ^<ThreadMirror> = (
	thread resumeSlowly.
)
public stepInto ^<ThreadMirror> = (
	thread stepInto.
)
public suspendedActivation ^<ActivationMirror | nil> = (
	nil = thread suspendedActivation ifTrue: [^nil].
	^ActivationMirror reflecting: thread suspendedActivation thread: thread
)
public terminate ^<ThreadMirror> = (
	thread terminate.
)
) : (
)
private class TransientSlotDeclarationBuilder reflecting: ir in: builder = (|
private intermediate = ir.
public definingMixin = builder.
|) (
public accessModifier = (
	^intermediate accessModifier
)
public isMutable = (
	^intermediate isMutable
)
public metadata ^<Array[Metadata]> = (
	^metadataFrom: source
)
public name = (
	^intermediate name
)
public source ^<String> = (
	^intermediate source
)
) : (
)
private class TransientSlotDeclarationMirror descriptor: d mixin: mxn = (|
private descriptor = d.
public definingMixin = mxn.
|) (
public accessModifier ^<Symbol> = (
	(* Not `descriptor accessModifier`, which is always private to prevent overrides. *)
	^getter accessModifier
)
private getter ^<Method> = (
	| getterSelector = name. |
	^mixin _methods detect: [:method | method selector = getterSelector]
)
private initializer ^<Method> = (
	| initializerSelector = name , '`init'. |
	^mixin _methods detect: [:method | method selector = initializerSelector]
)
public isKindOfTransientSlotDeclarationMirror ^<Boolean> = (
	^true
)
public isMutable ^<Boolean> = (
	^descriptor isMutable
)
public literals ^<Set[Object]> = (
	^(Printer for: initializer) literals
)
public metadata ^<Array[Metadata]> = (
	^metadataFrom: source
)
private mixin ^<InstanceMixin> = (
	^reflectees at: definingMixin
)
public name ^<Symbol> = (
	^demangleTransientSlotName: descriptor name
)
public selectors ^<Set[String]> = (
	^(Printer for: initializer) selectors
)
public source ^<String> = (
	^descriptor metadata
)
) : (
)
private allInstancesOf: cls = (
	(* :pragma: primitive: 141 *)
	panic.
)
private allReferersOf: target = (
	(* :pragma: primitive: 133 *)
	panic.
)
private allocate: cls = (
	(* :pragma: primitive: 140 *)
	panic.
)
buildIntermediate: i <IntermediateMixin> from: mixin <AbstractMixin> within: ec = (
	| initializers = List new. |

	mixin _methods do:
		[:method |
		|
		selector = method selector.
		imethod = intermediates IntermediateMethod new.
		|
		imethod method: method.
		imethod methodMixin: mixin.
		imethod selector: selector.
		imethod accessModifier: method accessModifier.
		imethod isSynthetic: method isSynthetic.
		imethod source: method source.
		(isSubinitializerSelector: selector) ifTrue:
			[initializers add: imethod].
		imethod isSynthetic ifFalse:
			[i methods add: imethod]].

	mixin isMeta ifTrue:
		[ | factoryName factoryM factoryIR |
		factoryName:: mixin _instanceMixin _primaryFactorySelector.
		factoryM:: mixin _methods detect: [:ea | ea selector = factoryName].
		factoryIR:: intermediates IntermediateMethod new.
		factoryIR method: factoryM.
		factoryIR methodMixin: mixin.
		factoryIR selector: factoryName.
		factoryIR accessModifier: factoryM accessModifier.
		factoryIR isSynthetic: true.
		i declaration factory: factoryIR.
		^self].

	i declaration initializers: initializers.

	mixin _slots do:
		[:slot |
		| islot = intermediates IntermediateSlotDeclaration new. |
		islot name: slot name.
		islot isMutable: slot isMutable.
		islot accessModifier: slot accessModifier.
		(isSyntheticSlotSelector: islot name) ifFalse:
			[i slots add: islot].
		slot isTransient ifTrue:
			[ | islot = intermediates IntermediateTransientSlotDeclaration new. |
			islot name: (demangleTransientSlotName: slot name).
			islot source: slot metadata.
			islot getter: (buildIntermediateMethod: islot name within: mixin).
			islot setter: (buildIntermediateMethod: islot name, ':' within: mixin).
			islot initializer: (buildIntermediateMethod: islot name, '`init' within: mixin).
			i transientSlots add: islot].
		].

	mixin _nestedMixins do:
		[:nestedMixin <InstanceMixin> |
		i nestedClasses add: (buildIntermediateFor: nestedMixin within: ec)].

	nil = mixin _enclosingMixin ifFalse:
		[ |
		name = i declaration name.
		accessorM <Method>
		accessorIR <IntermediateMethod>
		|
		accessorM:: mixin _enclosingMixin _methods detect: [:ea | ea selector = name].
		accessorIR:: intermediates IntermediateMethod new.
		accessorIR method: accessorM.
		accessorIR methodMixin: mixin.
		accessorIR selector: name.
		accessorIR accessModifier: accessorM accessModifier.
		accessorIR isSynthetic: true.
		i declaration accessor: accessorIR].
)
buildIntermediateFor: mixin <InstanceMixin> within: ec <ICD> ^<IntermediateClassDeclaration> = (
	| i = intermediates IntermediateClassDeclaration new. |
	i name: mixin _name.
	i headerSource: mixin _headerSource.
	i factoryName: mixin _primaryFactorySelector.
	i enclosingClass: ec.
	i existingMixin: mixin.
	buildIntermediate: i instanceSide from: mixin within: i.
	buildIntermediate: i classSide from: mixin _classMixin within: i.
	^i
)
buildIntermediateMethod: selector within: mixin <InstanceMixin> = (
	| method methodIR |
	method:: mixin _methods detect: [:ea | ea selector = selector] ifNone: [^nil].
	methodIR:: intermediates IntermediateMethod new.
	methodIR method: method.
	methodIR methodMixin: mixin.
	methodIR selector: selector.
	methodIR accessModifier: method accessModifier.
	methodIR isSynthetic: true.
	^methodIR
)
private classOf: object = (
	(* :pragma: primitive: 127 *)
	panic.
)
private compiler = (
	nil = compilerX ifTrue: [constructCompiler].
	^compilerX
)
private computeDebugInfo: rawMethod = (
	| metadata = rawMethod metadata. definingMixin = rawMethod mixin. |

	(* Expression *)
	metadata isKindOfDebugInfo ifTrue:
		[^metadata].

	(* Regular method *)
	rawMethod isSynthetic ifFalse:
		[^(compiler compileMethodSource: rawMethod source within: (mxn: definingMixin)) debugInfo].

	definingMixin isMeta ifFalse:
		[(* Nested class accessor *)
		 definingMixin _nestedMixins do:
			[:nestedMixin | nestedMixin _name = rawMethod selector ifTrue:
				[^(compiler
					compileClassHeader: nestedMixin _headerSource
					within: (mxn: definingMixin)) accessor debugInfo]].
		 (* Instance initializer *)
		 (isSubinitializerSelector: rawMethod selector) ifTrue:
			[^(compiler
				compileClassHeader: rawMethod mixin _headerSource
				within: (mxn: definingMixin _enclosingMixin)) initializers first debugInfo].
		 (* Transient slot getter / setter / initializer *)
		 definingMixin _slots do:
			[:slot | slot isTransient ifTrue:
				[ |
				  getterName = demangleTransientSlotName: slot name.
				  setterName = getterName, ':'.
				  initName = getterName, '`init'.
				  source = slot metadata.
				  |
				rawMethod selector = getterName ifTrue:
					[^(compiler
						compileTransientSlotSource: source
						within: (mxn: definingMixin)) getter debugInfo].
				rawMethod selector = setterName ifTrue:
					[^(compiler
						compileTransientSlotSource: source
						within: (mxn: definingMixin)) setter debugInfo].
				rawMethod selector = initName ifTrue:
					[^(compiler
						compileTransientSlotSource: source
						within: (mxn: definingMixin)) initializer debugInfo]]]].

	(* Factory *)
	definingMixin isMeta ifTrue:
		[definingMixin _instanceMixin _primaryFactorySelector = rawMethod selector ifTrue:
			[^(compiler
				compileClassHeader: definingMixin _instanceMixin _headerSource
				within: (mxn: definingMixin _enclosingMixin)) factory debugInfo]].

	panic.
)
private constructCompiler = (
	| asts compilation |
	asts:: namespace NewspeakASTs
		usingPlatform: cachedPlatform.
	parsingX:: namespace NewspeakPredictiveParsing
		usingPlatform: cachedPlatform
		asts: asts.
	intermediatesX:: namespace Intermediates
		usingPlatform: cachedPlatform
		internalKernel: internalKernel.
	compilation:: namespace Newspeak2PrimordialSoupCompilation
		usingPlatform: cachedPlatform
		asts: asts
		parsing: parsingX
		intermediates: intermediatesX.
	compilerX:: compilation Compiler new.
)
private copiedOf: closure <Closure> at: index <Integer> ^<Object> = (
	(* :pragma: primitive: 154 *)
	panic.
)
private copiedOf: closure <Closure> at: index <Integer> put: value <Object> ^<Object> = (
	(* :pragma: primitive: 155 *)
	panic.
)
private currentActivation ^<Activation> = (
	(* :pragma: primitive: 164 *)
	panic.
)
private definingActivationOf: closure <Closure> ^<Activation> = (
	(* :pragma: primitive: 148 *)
	panic.
)
private demangleTransientSlotName: name = (
	(name endsWith: '`slot') ifFalse: [panic].
	^(name copyFrom: 1 to: name size - 5) asSymbol
)
private elementsOf: old forwardIdentityToElementsOf: new = (
	(* :pragma: primitive: 183 *)
	panic.
)
private enclosingObjectOf: behavior = (
	^self slotOf: behavior at: 3
)
private formatOf: behavior = (
	^self slotOf: behavior at: 6
)
private heapSizeOf: object = (
	(* :pragma: primitive: 137 *)
	panic.
)
private identityHashOf: a = (
	(* :pragma: primitive: 136 *)
	panic.
)
private initialBCIOf: closure <Closure> ^<Integer> = (
	(* :pragma: primitive: 150 *)
	panic.
)
private intermediates = (
	nil = intermediatesX ifTrue: [constructCompiler].
	^intermediatesX
)
private is: a identicalTo: b = (
	(* :pragma: primitive: 135 *)
	panic.
)
private isBehavior: object = (
	| cls |
	cls:: classOf: object.
	Metaclass = cls ifTrue: [^true (* [object] is a metaclass *)].
	cls:: classOf: cls.
	Metaclass = cls ifTrue: [^true (* [object] is a class *)].
	cls:: classOf: cls.
	Metaclass = cls ifFalse: [panic].
	^false
)
private isSubinitializerSelector: selector = (
	(selector startsWith: 'mixinInitializer`') ifTrue: [^true].
	(selector startsWith: 'initializer`') ifTrue: [^true].
	^false
)
private isSyntheticSlotSelector: selector = (
	^selector endsWith: '`slot'
)
private metadataFrom: source <String> ^<Array[Metadata]> = (
	nil = source ifTrue: [^nil].
	^(parsing Parser for: source) keepComments asArray
		collect: [:tuple | Metadata tag: (tuple at: 1) payload: (tuple at: 2)]
)
private methodsOf: behavior = (
	^self slotOf: behavior at: 2
)
private mixinOf: behavior = (
	^self slotOf: behavior at: 4
)
private mxn: mixin = (
	nil = mixin ifTrue: [^nil].
	^MixinMirror reflecting: mixin
)
private numCopiedOf: closure <Closure> ^<Integer> = (
	(* :pragma: primitive: 147 *)
	panic.
)
private panic = (
	(* :pragma: primitive: 187 *)
)
private parsing = (
	nil = parsingX ifTrue: [constructCompiler].
	^parsingX
)
private slotOf: object at: index = (
	(* :pragma: primitive: 130 *)
	panic.
)
private slotOf: object at: index put: value = (
	(* :pragma: primitive: 131 *)
	panic.
)
private subclassesOf: klass = (
	^self slotOf: klass at: 8
)
private superclassOf: behavior = (
	^self slotOf: behavior at: 1
)
) : (
)
